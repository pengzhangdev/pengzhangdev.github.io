



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="The documents of Werther Zhang">
      
      
        <link rel="canonical" href="https://wertherzhang.com/dlmalloc浅析/">
      
      
        <meta name="author" content="Werther Zhang">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="en, jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>dlmalloc 浅析 - 万卷茅屋</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#2196f3">
      
    
    
      <script src="../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700|Ubuntu+Mono&display=fallback">
        <style>body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Ubuntu Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="blue" data-md-color-accent="light-blue">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#dlmalloc" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://wertherzhang.com" title="万卷茅屋" class="md-header-nav__button md-logo">
          
            <i class="md-icon">whatshot</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              万卷茅屋
            </span>
            <span class="md-header-nav__topic">
              
                dlmalloc 浅析
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href=".." title="万卷茅屋" class="md-tabs__link">
        万卷茅屋
      </a>
    
  </li>

      
        
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../zram/" title="Android" class="md-tabs__link md-tabs__link--active">
          Android
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../跟我读源码--换个角度看init/" title="跟我读源码" class="md-tabs__link">
          跟我读源码
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../slackbot/" title="Python" class="md-tabs__link">
          Python
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../C-CPP-N诫/" title="搬运工" class="md-tabs__link">
          搬运工
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://wertherzhang.com" title="万卷茅屋" class="md-nav__button md-logo">
      
        <i class="md-icon">whatshot</i>
      
    </a>
    万卷茅屋
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="万卷茅屋" class="md-nav__link">
      万卷茅屋
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../about/" title="关于" class="md-nav__link">
      关于
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Android
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Android
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../zram/" title="zram" class="md-nav__link">
      zram
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../android8-partiton-table/" title="Android8分区表分析" class="md-nav__link">
      Android8分区表分析
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Android-AB-system-update/" title="AB系统升级" class="md-nav__link">
      AB系统升级
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../recovery5.0详解/" title="Recovery5二次开发详解" class="md-nav__link">
      Recovery5二次开发详解
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Android-memory-debug/" title="Android内存调试总结" class="md-nav__link">
      Android内存调试总结
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../SEAndroid规则介绍/" title="Android SELinux 规则介绍" class="md-nav__link">
      Android SELinux 规则介绍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tcmalloc2.1浅析/" title="tcmalloc2.1 浅析" class="md-nav__link">
      tcmalloc2.1 浅析
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        dlmalloc 浅析
      </label>
    
    <a href="./" title="dlmalloc 浅析" class="md-nav__link md-nav__link--active">
      dlmalloc 浅析
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#dlmalloc_1" title="dlmalloc介绍" class="md-nav__link">
    dlmalloc介绍
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" title="算法概览" class="md-nav__link">
    算法概览
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mspace" title="非MSPACE代码逻辑分析" class="md-nav__link">
    非MSPACE代码逻辑分析
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#head" title="head 域中变量的说明:" class="md-nav__link">
    head 域中变量的说明:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" title="被覆盖的数据结构" class="md-nav__link">
    被覆盖的数据结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dlmalloc_2" title="dlmalloc代码分析" class="md-nav__link">
    dlmalloc代码分析
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" title="小内存规则一" class="md-nav__link">
    小内存规则一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="小内存规则三" class="md-nav__link">
    小内存规则三
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="大内存分配规则一" class="md-nav__link">
    大内存分配规则一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" title="大小内存分配规则二" class="md-nav__link">
    大小内存分配规则二
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" title="大小内存分配规则四" class="md-nav__link">
    大小内存分配规则四
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="大小内存分配规则五" class="md-nav__link">
    大小内存分配规则五
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dlfree" title="dlfree代码分析" class="md-nav__link">
    dlfree代码分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" title="总结" class="md-nav__link">
    总结
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../binder/" title="binder" class="md-nav__link">
      binder
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../jemalloc剖析/" title="jemalloc" class="md-nav__link">
      jemalloc
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      跟我读源码
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        跟我读源码
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../跟我读源码--换个角度看init/" title="换个角度看init" class="md-nav__link">
      换个角度看init
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Python
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Python
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../slackbot/" title="slackbot详细说明" class="md-nav__link">
      slackbot详细说明
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      搬运工
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        搬运工
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../C-CPP-N诫/" title="C and CPP N 诫" class="md-nav__link">
      C and CPP N 诫
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#dlmalloc_1" title="dlmalloc介绍" class="md-nav__link">
    dlmalloc介绍
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" title="算法概览" class="md-nav__link">
    算法概览
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mspace" title="非MSPACE代码逻辑分析" class="md-nav__link">
    非MSPACE代码逻辑分析
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#head" title="head 域中变量的说明:" class="md-nav__link">
    head 域中变量的说明:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" title="被覆盖的数据结构" class="md-nav__link">
    被覆盖的数据结构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dlmalloc_2" title="dlmalloc代码分析" class="md-nav__link">
    dlmalloc代码分析
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" title="小内存规则一" class="md-nav__link">
    小内存规则一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="小内存规则三" class="md-nav__link">
    小内存规则三
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="大内存分配规则一" class="md-nav__link">
    大内存分配规则一
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" title="大小内存分配规则二" class="md-nav__link">
    大小内存分配规则二
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" title="大小内存分配规则四" class="md-nav__link">
    大小内存分配规则四
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" title="大小内存分配规则五" class="md-nav__link">
    大小内存分配规则五
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dlfree" title="dlfree代码分析" class="md-nav__link">
    dlfree代码分析
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" title="总结" class="md-nav__link">
    总结
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="dlmalloc">dlmalloc浅析<a class="headerlink" href="#dlmalloc" title="Permanent link">&para;</a></h1>
<ul>
<li>version 1.0 by Werther Zhang @ 2014.03.15 Write done @WizNote</li>
<li>Version 1.1   by Werther Zhang @ 2014.03.20 Export to @Word</li>
<li>Version  1.2  by Werther Zhang @ 2016.07.02 Move to @leanote</li>
</ul>
<p>来源: https://pengzhangdev.github.io/dlmalloc%E6%B5%85%E6%9E%90/</p>
<h2 id="dlmalloc_1">dlmalloc介绍<a class="headerlink" href="#dlmalloc_1" title="Permanent link">&para;</a></h2>
<p>dlmalloc在某些程度上说，是最好的内存管理工具之一。它是由Doug Lea 在1987年开始编写，所以大部分人会称呼它为Doug Lea's Malloc， 简称dlmalloc。</p>
<h2 id="_1">算法概览<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>dlmalloc 根据内存粒度的大小分别使用chunk和segment进行管理。Segment是通过sbrk分配，类似进程的数据段，属于极少遇到的情况。Dlmalloc中大量存在的内存块是chunk。Chunk的结构如下。</p>
<p>被用户使用的chunk结构看起来像下面这样（非精确图）：</p>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/dlmalloc浅析-0.png" /></p>
<p>而未被使用的chunk看起来如下（非精确图）：</p>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/dlmalloc浅析-1.png" />
<br>
在虚拟地址上，dlmalloc会保证空闲的内存块存在“孤岛效应”，也就是说，任一块空闲内存块的前后必定是被使用的内存块。因为在free或者其他任何时候，dlmalloc总是会合并空闲的内存块。
<br>
对 于chunk，根据其大小，分为大内存和小内存。小内存由32个双向链表通过分箱（每一个箱子对应一个大小，每个箱子中存放一个双向链表）进行管理，而大 内存统一由bitwise tries树通过分箱（每一个箱子对应一个内存范围，每一个箱子中存放一棵树，每一棵树中若有等大小的内存，由双向链表管理） 进行管理。
<br>
每一个chunk的大小必须为8byte的整数倍。所以在’size of chunk’ 域的低三位存放了该chunk属性的标志位。
<br>
P (PINUSE_BIT) 位, 保 存在内存块大小(一般是双字节的倍数)的未使用的低位, 是一个表示前一个内存块是否被使用的bit位.如果这个bit位被清理了,那么在当前内存块 之 前的一个字 大小数据保存着前一个内存块的大小,用于寻找前一个内存块.而 第一个内存块这个bit位总是被置上的,防止访问不存在的内存区域.如果某个 内 存块的 pinuse被设置了,你就无法决定上一个内存块的大小,并且如果你真的尝 试这 么做了,有可能内存访问出错.
<br>
C (CINUSE_BIT) bit位, 保存在内存块的第二低的bit位,冗余地记录着当前块是 否被使用了(除非当前内存块是被映射的).这个冗余信息用于在free和realloc操 作时的检查,并且减少在执行free和合并内存块时的间接操作.
<br>
任何新分配的内存块必须都设置了cinuse和pinuse.这意味着,任何分配了的内 存块的边界要么是一个先前分配并且仍然在使用(in-use)的内 存块,要么是它自 己的大内存区域(segment)的地址.这样确保所有的内存申请(allocations)都是从任何能找到的内存块的“最低”部分 获取.进一步地说,不可能存在一个空闲内 存块在物理上紧邻着另 一个空闲内存块,所以每一个空闲内存块被证实在使用 (inuse)的内存块或者内存尾 部之前和之后.
<br>
注意: 当前块的 ’foot’实际上代表着下一个内存块的prev_foot.这使对齐等操 作处理变得容易但会使人在扩展或维护这份代码时感到困惑.
<br>
以下是对特殊的内存块的说明:</p>
<ul>
<li>特 殊的内存块’top’是最顶上的可用内存块(i.e., 紧邻着可用内存的边界). 这块内存块会被特殊对待. Top 内存块不会被包含在任何的内存分 类箱里, 只有在没有任何其他内存块可使用时,才被使用,并且在它非常大时(查看 M_TRIM_THRESHOLD) 会被释放一部分回系统.在实际 上,top内存块一般被认 为是比其他所有的内存块都大.Top内存块从来不会更新它的尾部数据区域因 为根本没有内存块会在索引上紧跟其后.但是,空间 还是会分配给它 (TOP_FOOT_SIZE) 用户做内存块的拆分和合并,当空间需要扩展时.</li>
<li>dv chunk 是保存了最近被使用并切割过的内存块，保存在全局的gm中。它不归属到双向链表或者树中管理。但当它被替换时，也会加入内存管理中。
<br>
Bitwise trie 树, 实际上是结合了二叉树和trie树(又叫字典树, 前缀数).二叉树只有左右子树. Trie树是一种有序树,用于保存关联数组,类似 hash table, 有key 和 value 结构. 如下图.key 实际上就是到达value的路径.而bitwise trie, 它是将 key设置为0/1, 所以, 是一棵二叉树.在dlmalloc的bitwise trie tree中, 0 代表进入左子树, 1 代表进入右子 树. 而key的长度对应路径的深度.参考 [treebins和树管理图解] 的图,假设我们现在要查找的是512对应的结点, 则将520对 应二进制码是1000001000, 对应的箱子号是2号,则其表示的内存范围为256, 特征码长度为8, 也就是00001000.考虑到, 所有请 求大小为8byte倍数,所以, 实际特征码为00001, 树深为5, 前4层为左子树,第五层为右子树.但刚才描述的是trie树和 bitwise trie 树, 不是dlmalloc使用的树.</li>
</ul>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/dlmalloc浅析-2.png" /></p>
<h2 id="mspace">非MSPACE代码逻辑分析<a class="headerlink" href="#mspace" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>
<span class="kt">size_t</span>               <span class="n">prev_foot</span><span class="p">;</span>  <span class="cm">/* 如果前一个内存块空闲,表示前一个内存块的大小 */</span>
<span class="kt">size_t</span>               <span class="n">head</span><span class="p">;</span>       <span class="cm">/* 大小和inuse bit位*/</span>
<span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* 如果是空闲内存块,指向双向链表*/</span>
<span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">malloc_chunk</span>  <span class="n">mchunk</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">mchunkptr</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">sbinptr</span><span class="p">;</span>  <span class="cm">/* 内存块分类箱的类型 */</span><span class="err">﻿​</span>
</pre></div>


<h3 id="head">head 域中变量的说明:<a class="headerlink" href="#head" title="Permanent link">&para;</a></h3>
<p>PINUSE_BIT 在前一个相邻的内存块被使用时,这个标志位被置上. CINUSE_BIT 在当前内存块被使用时,这个标志位被置上. FLAG4_BIT 在当前版本的dlmalloc中未被使用</p>
<p><br>
如 何做到在head中既存放块大小又存放标志位的呢?首先提到一点是,所有的块的 大小都是按最少8bit对齐的,换句话说,表示大小的数字,低3位必定为 0,所以就有 效地利用了低3位存放标志位.所以,获取chunk的大小用下面的宏,将head的低三 位清成0,取出.
<br></p>
<div class="codehilite"><pre><span></span><span class="cp">#define chunksize(p)        ((p)-&gt;head &amp; ~(FLAG_BITS))</span>
</pre></div>


<p><br>
下面介绍下dlmalloc维护的一个全局数据结构.</p>
<div class="codehilite"><pre><span></span><span class="mi">2579</span> <span class="k">struct</span> <span class="n">malloc_state</span> <span class="p">{</span> 
<span class="mi">2580</span>   <span class="n">binmap_t</span>   <span class="n">smallmap</span><span class="p">;</span>  <span class="c1">// 32bit, 小内存箱子的位图.</span>
<span class="mi">2581</span>   <span class="n">binmap_t</span>   <span class="n">treemap</span><span class="p">;</span>    <span class="c1">// 32bit, 大内存箱子的位图</span>
<span class="mi">2582</span>   <span class="kt">size_t</span>     <span class="n">dvsize</span><span class="p">;</span>           <span class="c1">//  dv chunk 的大小</span>
<span class="mi">2583</span>   <span class="kt">size_t</span>     <span class="n">topsize</span><span class="p">;</span>          <span class="c1">//  top chunk的大小</span>
<span class="mi">2584</span>   <span class="kt">char</span><span class="o">*</span>      <span class="n">least_addr</span><span class="p">;</span>    <span class="c1">//  dlmalloc管理的内存的最小地址,也就是最小的segment 基地址.</span>
<span class="mi">2585</span>   <span class="n">mchunkptr</span>  <span class="n">dv</span><span class="p">;</span>            <span class="c1">// dv chunk. 最近被分割使用的chunk</span>
<span class="mi">2586</span>   <span class="n">mchunkptr</span>  <span class="n">top</span><span class="p">;</span>           <span class="c1">// top chunk. 顶部,靠近有效内存的chunk,详见总结图.</span>
<span class="mi">2587</span>   <span class="kt">size_t</span>     <span class="n">trim_check</span><span class="p">;</span>    <span class="c1">// 检查top chunk大小是否超的函数.</span>
<span class="mi">2588</span>   <span class="kt">size_t</span>     <span class="n">release_checks</span><span class="p">;</span>  
<span class="mi">2589</span>   <span class="kt">size_t</span>     <span class="n">magic</span><span class="p">;</span> 
<span class="mi">2590</span>   <span class="n">mchunkptr</span>  <span class="n">smallbins</span><span class="p">[(</span><span class="n">NSMALLBINS</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>   <span class="c1">// 32个链表头</span>
<span class="mi">2591</span>   <span class="n">tbinptr</span>    <span class="n">treebins</span><span class="p">[</span><span class="n">NTREEBINS</span><span class="p">];</span>           <span class="c1">// 32棵树</span>
<span class="mi">2592</span>   <span class="kt">size_t</span>     <span class="n">footprint</span><span class="p">;</span> 
<span class="mi">2593</span>   <span class="kt">size_t</span>     <span class="n">max_footprint</span><span class="p">;</span> 
<span class="mi">2594</span>   <span class="kt">size_t</span>     <span class="n">footprint_limit</span><span class="p">;</span> <span class="cm">/* zero means no limit */</span> 
<span class="mi">2595</span>   <span class="n">flag_t</span>     <span class="n">mflags</span><span class="p">;</span> 
<span class="mi">2596</span> <span class="err">#</span><span class="k">if</span> <span class="n">USE_LOCKS</span> 
<span class="mi">2597</span>   <span class="n">MLOCK_T</span>    <span class="n">mutex</span><span class="p">;</span>     <span class="cm">/* locate lock among fields that rarely change */</span> 
<span class="mi">2598</span> <span class="err">#</span><span class="n">endif</span> <span class="cm">/* USE_LOCKS */</span> 
<span class="mi">2599</span>   <span class="n">msegment</span>   <span class="n">seg</span><span class="p">;</span>        <span class="c1">//  segment链表.</span>
<span class="mi">2600</span>   <span class="kt">void</span><span class="o">*</span>      <span class="n">extp</span><span class="p">;</span>      <span class="cm">/* Unused but available for extensions */</span> 
<span class="mi">2601</span>   <span class="kt">size_t</span>     <span class="n">exts</span><span class="p">;</span> 
<span class="mi">2602</span> <span class="p">};</span><span class="err">﻿​</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="n">mchunkptr</span>  <span class="n">smallbins</span><span class="p">[(</span><span class="n">NSMALLBINS</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>  
</pre></div>


<p>这里会有个疑问,理论上, 32个链表头,我们会使用<code>struct malloc_chunk  smallbins[NSMALLBINS];</code>  但这里不使用的原因是, 对于链表头而言,  <code>malloc_chunk</code>的 <code>prev_foot</code>和<code>head</code>两个域是没有被使用的,实际需要的大小是2个指针大 小.所以,dlmalloc使用了覆盖的方法. 前一个 malloc_state 的fb/bk 踩了后一个的 malloc_state的 prev_foot/head.所以大小应该为 32 * 8 + 8, 也就是33 * 2 个指针大小.</p>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/dlmalloc浅析-3.png" /></p>
<h3 id="_2">被覆盖的数据结构<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>当内存块未被使用时,他们作为列表或者树的节点.
<br>
小内存(“Small”) 块存储在环形双向链表中,看起来像如下这样.</p>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/dlmalloc浅析-4.png" /></p>
<p>而 大 的内存块使用内存块大小为关键字的bitwise digital tree (又叫aka tree).因为malloc_tree_trunks只是 用于大小大于256bytes的空闲内存块,他们 的大小不会受到用户申请的内存大小的限制.每 一个节点的结构看起来像如下这 样.</p>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/dlmalloc浅析-5.png" /></p>
<p>每一棵树都拥有唯一的内存块大小.而具有同样大小的内存块会被安排在双向链 表里,与最老的内存块一起(指,以FIFO的规则,下一个要被使用的内存块).如果一 个具有同样大小的内存块被插入,它就会用类似小内存的fb/bk的指针一样的方式,从 原有的节点移除.
<br></p>
<p>每 一 棵树包含大小为2的乘方范围的内存块(最小为0x100 &lt;= x &lt; 0x180),在树 的每一层都会被分成一半,即小的一半 (0x100 &lt;= x &lt; 0x140)作为左子树,大的一 半作为右子树(0x140 &lt;= x &lt; 0x180).
<br></p>
<p>通过使用这种规则,每一个节点的左子树包含的内存块大小都小雨其右子树.
<br></p>
<p>Smallbins和双向链表管理小内存图解。</p>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/dlmalloc浅析-6.png" /></p>
<p>Treebins和树管理大内存的图解：</p>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/dlmalloc浅析-7.png" /></p>
<h2 id="dlmalloc_2">dlmalloc代码分析<a class="headerlink" href="#dlmalloc_2" title="Permanent link">&para;</a></h2>
<p>dlmalloc 对小内存分配有如下5个规则(按优先级顺序)： </p>
<ol>
<li>如果与请求内存大小匹配的箱子存在空闲,则使用当前箱子，否则使用临近的 箱子。在能不分割内存的情况下尽量不分割内存。 </li>
<li>如果dv chunk足够大，那么使用dv chunk。 dv chunk是指最近一次小内存 申请时使用的内存块。 这个规则是，尽量保证分配的内存连续。 </li>
<li>在smallbin和treebin中寻找可以使用的内存块，并分割。将剩下的内存 块保存到dv chunk中。 </li>
<li>如果top chunk 足够大，则使用top chunk</li>
<li>如果请求内存实在太大，则使用系统分配内存。</li>
</ol>
<p><br>
大内存分配的规则：</p>
<ol>
<li>在treebin中找到最适合的最小内存，如果它比dv chunk的更合适，就使用它， 如果有需要就分割它。 </li>
<li>如果dv chunk 比其他所有的更合适，使用dv chunk。 </li>
<li>如果top 足够大，使用top chunk。 </li>
<li>如果请求的大小 &gt;= mmap threshold, 则使用系统的mmap。</li>
<li>直接从系统分配内存并使用。</li>
</ol>
<p><br></p>
<h3 id="_3">小内存规则一<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p><br></p>
<div class="codehilite"><pre><span></span><span class="mi">4597</span>     <span class="nf">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;=</span> <span class="n">MAX_SMALL_REQUEST</span><span class="p">)</span> <span class="p">{</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="c1">// MAX_SMALL_REQUEST 实现</span>
<span class="mi">2577</span> <span class="err">#</span><span class="n">define</span> <span class="n">MAX_SMALL_REQUEST</span> <span class="p">(</span><span class="n">MAX_SMALL_SIZE</span> <span class="o">-</span> <span class="n">CHUNK_ALIGN_MASK</span> <span class="o">-</span> <span class="n">CHUNK_OVERHEAD</span><span class="p">)</span>
</pre></div>


<p>这里bytes为申请的内存大小, <code>MAX_SMALL_REQUEST</code>就是之前提到过的最大的小内存块的大小,就是256byte,即,256byte以下的所有内存都是在双向链表中匹配.
<br></p>
<div class="codehilite"><pre><span></span><span class="mi">4600</span>       <span class="n">nb</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="n">MIN_REQUEST</span><span class="p">)</span><span class="o">?</span> <span class="nl">MIN_CHUNK_SIZE</span> <span class="p">:</span> <span class="n">pad_request</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="mi">2225</span> <span class="err">#</span><span class="n">define</span> <span class="n">MIN_REQUEST</span>         <span class="p">(</span><span class="n">MIN_CHUNK_SIZE</span> <span class="o">-</span> <span class="n">CHUNK_OVERHEAD</span> <span class="o">-</span> <span class="n">SIZE_T_ONE</span><span class="p">)</span>

<span class="mi">2228</span> <span class="err">#</span><span class="n">define</span> <span class="n">pad_request</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> \
<span class="mi">2229</span>    <span class="p">(((</span><span class="n">req</span><span class="p">)</span> <span class="o">+</span> <span class="n">CHUNK_OVERHEAD</span> <span class="o">+</span> <span class="n">CHUNK_ALIGN_MASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CHUNK_ALIGN_MASK</span><span class="p">)</span>
</pre></div>


<p>这里nb就是加上协议数据后的实际dlmalloc会分配的内存块大小.前文笔者提到过,小内存块的最小值为8byte,所以,不论申请的内存多小,都使用最小值.
<br></p>
<div class="codehilite"><pre><span></span><span class="mi">4601</span>      <span class="n">idx</span> <span class="o">=</span> <span class="n">small_index</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="mi">2572</span> <span class="err">#</span><span class="n">define</span> <span class="n">SMALLBIN_SHIFT</span>    <span class="p">(</span><span class="mi">3U</span><span class="p">)</span>

<span class="mi">2825</span> <span class="err">#</span><span class="n">define</span> <span class="n">small_index</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>      <span class="p">(</span><span class="n">bindex_t</span><span class="p">)((</span><span class="n">s</span><span class="p">)</span>  <span class="o">&gt;&gt;</span> <span class="n">SMALLBIN_SHIFT</span><span class="p">)</span>
</pre></div>


<p>这里idx得到的是该内存块对应的smallbin箱子的箱号.前文在提到head时,提到过,小内存块的大小为8byte的倍数,所以,右移3位来定位对应箱子的箱号.
<br></p>
<div class="codehilite"><pre><span></span><span class="mi">4602</span>       <span class="n">smallbits</span> <span class="o">=</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">smallmap</span> <span class="o">&gt;&gt;</span> <span class="n">idx</span><span class="p">;</span>
</pre></div>


<p>smallmap 是各个箱子的位图,32bit,对应32个箱子,每一位为1表示该箱号中有对
应大小的内存块,为0则表示没有.该行代码是把对应箱号的比特位移到最右侧.
<br></p>
<div class="codehilite"><pre><span></span><span class="mi">4604</span>       <span class="nf">if</span> <span class="p">((</span><span class="n">smallbits</span> <span class="o">&amp;</span> <span class="mh">0x3U</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4605</span>         <span class="n">mchunkptr</span> <span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>
<span class="mi">4606</span>         <span class="n">idx</span> <span class="o">+=</span> <span class="o">~</span><span class="n">smallbits</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>       <span class="cm">/* Uses next bin if idx empty */</span>
<span class="mi">4607</span>         <span class="n">b</span> <span class="o">=</span> <span class="n">smallbin_at</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
</pre></div>


<p>这里 0x3U 低8位就是 0000 0011. 所以,smallbits&amp;0x3U 为真的条件如下:(上文提到,smallbits的最右位表示idx箱号是否有空闲块)</p>
<ul>
<li>低2位为 11. idx有空闲块,比idx大1箱号的有空闲块.</li>
<li>低2位为 10. idx无空闲块,比idx大1箱号的有空闲块.</li>
<li>低2位为 01. idx有空闲块,比idx大1箱号的无空闲块.</li>
</ul>
<p>4606行是在重新定位到真正有空闲块的箱号. ~smallbits &amp; 1 在当前箱子为0的
情况下,值为1;当前箱子为1的情况下,值为0.所以是有限是用正好满足大小的箱
子.
<br></p>
<div class="codehilite"><pre><span></span><span class="mi">2831</span> <span class="err">#</span><span class="n">define</span> <span class="n">smallbin_at</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="p">((</span><span class="n">sbinptr</span><span class="p">)((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">((</span><span class="n">M</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">smallbins</span><span class="p">[(</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">])))</span>
</pre></div>


<p>i 就是 idx, 而M则是gm(<em>需要在上文预先描述gm结构体成员作用</em>).smallbins(<em>需在上文描述</em>)就是双向链表数组,也就是对应箱号内部的空闲块链表的首地址.</p>
<p>值得高兴的是,我们拿到链表了,接下来就是取出空闲块,和一些标志位的处理了.
<br></p>
<div class="codehilite"><pre><span></span><span class="mi">4608</span>        <span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="mi">4609</span>        <span class="nf">assert</span><span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">small_index2size</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
<span class="mi">4610</span>        <span class="nf">unlink_first_small_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="mi">4611</span>        <span class="nf">set_inuse_and_pinuse</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">small_index2size</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
<span class="mi">4612</span>        <span class="n">mem</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="mi">4613</span>        <span class="nf">check_malloced_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4614</span>        <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
</pre></div>


<p>fd域是前一个链表节点.而B是表头, 也就是说,我们取链表的第一个元素,取到我们需要的内存块地址.这个assert其实就是确认下,当前的箱号的内存块大小跟当前内存块的大小是否匹配.</p>
<p><br></p>
<div class="codehilite"><pre><span></span><span class="mi">3629</span><span class="err">#</span><span class="n">define</span> <span class="n">unlink_first_small_chunk</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span> <span class="p">{</span>\
<span class="mi">3630</span>  <span class="n">mchunkptr</span> <span class="n">F</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>\
<span class="mi">3631</span>  <span class="nf">assert</span><span class="p">(</span><span class="n">P</span> <span class="o">!=</span> <span class="n">B</span><span class="p">);</span>\
<span class="mi">3632</span>  <span class="nf">assert</span><span class="p">(</span><span class="n">P</span> <span class="o">!=</span> <span class="n">F</span><span class="p">);</span>\
<span class="mi">3633</span>  <span class="nf">assert</span><span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="n">small_index2size</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>\
<span class="mi">3634</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">B</span> <span class="o">==</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>\
<span class="mi">3635</span>    <span class="n">clear_smallmap</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span>\
<span class="mi">3636</span>  <span class="p">}</span>\
<span class="mi">3637</span>  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">==</span> <span class="n">P</span><span class="p">))</span> <span class="p">{</span>\
<span class="mi">3638</span>    <span class="n">F</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>\
<span class="mi">3639</span>    <span class="n">B</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">F</span><span class="p">;</span>\
<span class="mi">3640</span>  <span class="p">}</span>\
<span class="mi">3641</span>  <span class="k">else</span> <span class="p">{</span>\
<span class="mi">3642</span>    <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>\
<span class="mi">3643</span>  <span class="p">}</span>\
<span class="mi">3644</span><span class="p">}</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="mi">2921</span><span class="err">#</span><span class="n">define</span> <span class="n">clear_smallmap</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>     <span class="p">((</span><span class="n">M</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">smallmap</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">idx2bit</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</pre></div>


<p>这里 B P F的关系是 F -&gt; P -&gt; B , 所以,理论上, P 不等于F 也不等于B,如
果相等,就意味着是空链表(只有表头).而如果B == F,  意味着该链表中只有一
个空闲内存块.取出该内存块之后,咱们要把该箱子标记为空(3635, 2921).当然,
更多的情况是从链表中移除节点P.
<br></p>
<div class="codehilite"><pre><span></span><span class="c1">// 4611 行函数实现</span>

<span class="mi">3058</span><span class="err">#</span><span class="n">define</span> <span class="n">set_inuse_and_pinuse</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>\
<span class="mi">3059</span>  <span class="p">((</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">|</span><span class="n">PINUSE_BIT</span><span class="o">|</span><span class="n">CINUSE_BIT</span><span class="p">),</span>\
<span class="mi">3060</span>  <span class="p">((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">|=</span> <span class="n">PINUSE_BIT</span><span class="p">)</span>
</pre></div>


<p>这就是在P 的head中置上CINUSE位和P 的下一块内存的head中设置上PINUSE位.</p>
<p>最后mem = chunk2mem(p);  就是取出传递个用户的有效内存地址,.
check_malloced_chunk(gm, mem, nb); 是调试用的,检查该分配的内存块的各个
属性是否正常.</p>
<p>到此,小内存的,正好符合或正好临近箱子有空闲块的逻辑分析完成,咱们拿到了
需要的内存.</p>
<h3 id="_4">小内存规则三<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>下面,是上述情况不满足,也就是当前内存请求对应的箱号idx的smallbits低2位为 00 ,也就是说,没有空闲块.</p>
<div class="codehilite"><pre><span></span><span class="mi">4617</span>      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&gt;</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">dvsize</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4618</span>        <span class="k">if</span> <span class="p">(</span><span class="n">smallbits</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</pre></div>


<p>(<em>dvsize需要在gm的分析中描述掉</em>)  smallbits != 0 意味着,在比请求的内存块大的箱子中,总有空闲块存在.所以接下来的目的是找到最小的空闲块.</p>
<div class="codehilite"><pre><span></span><span class="mi">4622</span>          <span class="n">binmap_t</span> <span class="n">leftbits</span> <span class="o">=</span> <span class="p">(</span><span class="n">smallbits</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">left_bits</span><span class="p">(</span><span class="n">idx2bit</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
<span class="mi">4623</span>          <span class="n">binmap_t</span> <span class="n">leastbit</span> <span class="o">=</span> <span class="n">least_bit</span><span class="p">(</span><span class="n">leftbits</span><span class="p">);</span>
<span class="mi">4624</span>          <span class="nf">compute_bit2idx</span><span class="p">(</span><span class="n">leastbit</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="mi">2917</span><span class="err">#</span><span class="n">define</span> <span class="n">idx2bit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>              <span class="p">((</span><span class="n">binmap_t</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span>

<span class="mi">2929</span><span class="err">#</span><span class="n">define</span> <span class="n">least_bit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>         <span class="p">((</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="mi">2932</span><span class="err">#</span><span class="n">define</span> <span class="n">left_bits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>         <span class="p">((</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">))</span>
</pre></div>


<p>4622 行 位与的右操作数是一个32bit的数，该数的低（idx+1）位为0,其余位为1;左操作数就是对应低idx位为0,同时代码逻辑走到这里，我们可以确定，低（idx+2）为0。
least_bit 的功能是，保留leftbits中从右往左的第一个为1的位，其余位为0. 则该leastbit对应的就是符合请求的最小内存块的位图。compute_bit2idx 是将leastit位图转换成箱号。 这里 i 就是获取到的箱号。</p>
<div class="codehilite"><pre><span></span><span class="mi">4625</span>          <span class="n">b</span> <span class="o">=</span> <span class="n">smallbin_at</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="mi">4626</span>          <span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="mi">4627</span>          <span class="nf">assert</span><span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">small_index2size</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="mi">4628</span>          <span class="nf">unlink_first_small_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</pre></div>


<p>拿到箱号之后，这块的逻辑与上文规则一的逻辑一样。</p>
<div class="codehilite"><pre><span></span><span class="mi">4629</span>          <span class="n">rsize</span> <span class="o">=</span> <span class="n">small_index2size</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
</pre></div>


<p>取出当前箱子的内存块大小，减去用户请求的大小，剩下的就是剩余的内存块，这个剩余内存块会放到dv chunk中。</p>
<div class="codehilite"><pre><span></span><span class="mi">4631</span>          <span class="nf">if</span> <span class="p">(</span><span class="n">SIZE_T_SIZE</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">rsize</span> <span class="o">&lt;</span> <span class="n">MIN_CHUNK_SIZE</span><span class="p">)</span>
<span class="mi">4632</span>            <span class="n">set_inuse_and_pinuse</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">small_index2size</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="mi">4633</span>          <span class="k">else</span> <span class="p">{</span>
<span class="mi">4634</span>            <span class="n">set_size_and_pinuse_of_inuse_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4635</span>            <span class="n">r</span> <span class="o">=</span> <span class="n">chunk_plus_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4636</span>            <span class="nf">set_size_and_pinuse_of_free_chunk</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rsize</span><span class="p">);</span>
<span class="mi">4637</span>            <span class="nf">replace_dv</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">rsize</span><span class="p">);</span>
<span class="mi">4638</span>          <span class="p">}</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="mi">2269</span><span class="err">#</span><span class="n">define</span> <span class="n">chunk_plus_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>  <span class="p">((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span>

<span class="mi">2284</span><span class="err">#</span><span class="n">define</span> <span class="n">set_size_and_pinuse_of_free_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>\
<span class="mi">2285</span>  <span class="p">((</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">|</span><span class="n">PINUSE_BIT</span><span class="p">),</span> <span class="n">set_foot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

<span class="mi">3063</span><span class="err">#</span><span class="n">define</span> <span class="n">set_size_and_pinuse_of_inuse_chunk</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>\
<span class="mi">3064</span>  <span class="p">((</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">|</span><span class="n">PINUSE_BIT</span><span class="o">|</span><span class="n">CINUSE_BIT</span><span class="p">))</span>

<span class="mi">3584</span><span class="err">#</span><span class="n">define</span> <span class="n">insert_small_chunk</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>\
<span class="mi">3585</span>  <span class="n">bindex_t</span> <span class="n">I</span>  <span class="o">=</span> <span class="n">small_index</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>\
<span class="mi">3586</span>  <span class="n">mchunkptr</span> <span class="n">B</span> <span class="o">=</span> <span class="n">smallbin_at</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span>\
<span class="mi">3587</span>  <span class="n">mchunkptr</span> <span class="n">F</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>\
<span class="mi">3588</span>  <span class="nf">assert</span><span class="p">(</span><span class="n">S</span> <span class="o">&gt;=</span> <span class="n">MIN_CHUNK_SIZE</span><span class="p">);</span>\
<span class="mi">3589</span>  <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smallmap_is_marked</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span>\
        <span class="c1">// 如果是对应箱号原状态为0,则置1.</span>
<span class="mi">3590</span>    <span class="n">mark_smallmap</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span>\
<span class="mi">3591</span>  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">)))</span>\
<span class="mi">3592</span>    <span class="n">F</span> <span class="o">=</span> <span class="n">B</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>\
<span class="mi">3593</span>  <span class="k">else</span> <span class="p">{</span>\
<span class="mi">3594</span>    <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>\
<span class="mi">3595</span>  <span class="p">}</span>\
<span class="mi">3596</span>  <span class="n">B</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">P</span><span class="p">;</span>\
<span class="mi">3597</span>  <span class="n">F</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">P</span><span class="p">;</span>\
<span class="mi">3598</span>  <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">F</span><span class="p">;</span>\
<span class="mi">3599</span>  <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>\
<span class="mi">3600</span><span class="p">}</span>

<span class="mi">3648</span><span class="err">#</span><span class="n">define</span> <span class="n">replace_dv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>\
<span class="mi">3649</span>  <span class="kt">size_t</span> <span class="n">DVS</span> <span class="o">=</span> <span class="n">M</span><span class="o">-&gt;</span><span class="n">dvsize</span><span class="p">;</span>\
<span class="mi">3650</span>  <span class="nf">assert</span><span class="p">(</span><span class="n">is_small</span><span class="p">(</span><span class="n">DVS</span><span class="p">));</span>\
<span class="mi">3651</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">DVS</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>\
<span class="mi">3652</span>    <span class="n">mchunkptr</span> <span class="n">DV</span> <span class="o">=</span> <span class="n">M</span><span class="o">-&gt;</span><span class="n">dv</span><span class="p">;</span>\
<span class="mi">3653</span>    <span class="n">insert_small_chunk</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">DV</span><span class="p">,</span> <span class="n">DVS</span><span class="p">);</span>\
<span class="mi">3654</span>  <span class="p">}</span>\
<span class="mi">3655</span>  <span class="n">M</span><span class="o">-&gt;</span><span class="n">dvsize</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>\
<span class="mi">3656</span>  <span class="n">M</span><span class="o">-&gt;</span><span class="n">dv</span> <span class="o">=</span> <span class="n">P</span><span class="p">;</span>\
<span class="mi">3657</span><span class="p">}</span>
</pre></div>


<p>如果剩余大小rsize小于MIN_CHUNK_SIZE，咱们直接将所有内存分配给用户。否则则分割内存，并将剩余的内存块转成mchunkptr， 即 r。我们然后，r相当于一个新的内存块，我们设置其head属性（size，PINUSE_BIT，CINUSE_BIT）。
replace_dv 中，我们先获得dv size，确认是小内存块。然后，就是把dv内存块插入到对应的箱号里。就跟之前，根据大小获取到对应箱号的链表头的逻辑一样，
只是这里是将内存块插入双向链表的第一个位置。
ok， 插入完成后，咱们把刚才分割剩下的内存存放到dv chunk中。</p>
<div class="codehilite"><pre><span></span><span class="mi">4639</span>          <span class="n">mem</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="mi">4640</span>          <span class="nf">check_malloced_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4641</span>          <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
</pre></div>


<p>这里我们返回内存给用户，规则三第一部分内存分配结束。</p>
<div class="codehilite"><pre><span></span><span class="mi">4644</span>        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">gm</span><span class="o">-&gt;</span><span class="n">treemap</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mem</span> <span class="o">=</span> <span class="n">tmalloc_small</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">nb</span><span class="p">))</span>
<span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4645</span>          <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4646</span>          <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
</pre></div>


<p>这里else 对应“4618        if (smallbits != 0) {” 。 也就是说，只有小内存的&gt;=请求内存大小的所有箱子不存在空闲内存快。 然后，我们检查treemap中是否存在空闲块，如果存在，则调用tmalloc_small。</p>
<div class="codehilite"><pre><span></span><span class="mi">2833</span><span class="err">#</span><span class="n">define</span> <span class="n">treebin_at</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>     <span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">M</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">treebins</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="mi">4527</span><span class="o">-</span><span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="n">tmalloc_small</span><span class="p">(</span><span class="n">mstate</span> <span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">4531</span>  <span class="n">binmap_t</span> <span class="n">leastbit</span> <span class="o">=</span> <span class="n">least_bit</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">treemap</span><span class="p">);</span>
<span class="mi">4532</span>  <span class="nf">compute_bit2idx</span><span class="p">(</span><span class="n">leastbit</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="mi">4533</span>  <span class="n">v</span> <span class="o">=</span> <span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">treebin_at</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="mi">4534</span>  <span class="n">rsize</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
</pre></div>


<p><code>least_bit</code> 的作用就是保留最右侧为1的bit位，其余位为0.所以，<code>least_bit</code>和<code>compute_bit2idx</code>的共同作用就是在treemap中找到最小的可用内存箱子。v和t即为找到的内存块树的根节点。</p>
<div class="codehilite"><pre><span></span><span class="mi">4536</span>  <span class="nf">while</span> <span class="p">((</span><span class="n">t</span> <span class="o">=</span> <span class="n">leftmost_child</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4537</span>    <span class="kt">size_t</span> <span class="n">trem</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
<span class="mi">4538</span>    <span class="k">if</span> <span class="p">(</span><span class="n">trem</span> <span class="o">&lt;</span> <span class="n">rsize</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4539</span>      <span class="n">rsize</span> <span class="o">=</span> <span class="n">trem</span><span class="p">;</span>
<span class="mi">4540</span>      <span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="mi">4541</span>    <span class="p">}</span>
<span class="mi">4542</span>  <span class="p">}</span>
</pre></div>


<p>这段代码是寻找t的最左子树。在前文我们介绍过aka树，每一棵树的做子树总小于其右子树。该代码就是在寻找满足用于请求大小nb的最接近的树的节点。（考虑到请求的字节nb&lt;=256byte, 而在tree中最小的chunksize &gt; 256byte 所以,不会出现负数.）</p>
<div class="codehilite"><pre><span></span><span class="mi">4545</span>    <span class="n">mchunkptr</span> <span class="n">r</span> <span class="o">=</span> <span class="n">chunk_plus_offset</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4546</span>    <span class="nf">assert</span><span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">rsize</span> <span class="o">+</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4547</span>    <span class="nf">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_next</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">)))</span> <span class="p">{</span>
<span class="mi">4548</span>      <span class="n">unlink_large_chunk</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="mi">4549</span>      <span class="k">if</span> <span class="p">(</span><span class="n">rsize</span> <span class="o">&lt;</span> <span class="n">MIN_CHUNK_SIZE</span><span class="p">)</span>
<span class="mi">4550</span>        <span class="n">set_inuse_and_pinuse</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">rsize</span> <span class="o">+</span> <span class="n">nb</span><span class="p">));</span>
<span class="mi">4551</span>      <span class="k">else</span> <span class="p">{</span>
<span class="mi">4552</span>        <span class="n">set_size_and_pinuse_of_inuse_chunk</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4553</span>        <span class="n">set_size_and_pinuse_of_free_chunk</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rsize</span><span class="p">);</span>
<span class="mi">4554</span>        <span class="n">replace_dv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">rsize</span><span class="p">);</span>
<span class="mi">4555</span>      <span class="p">}</span>
<span class="mi">4556</span>      <span class="k">return</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="mi">4557</span>    <span class="p">}</span>
<span class="mi">4558</span>  <span class="p">}</span>
</pre></div>


<p>(NOT READY)
这段代码跟上文小内存找到后处理的代码相似。唯一的区别是，unlink_large_chunk，所以我们看下unlink_large_chunk的实现.这个过程有三个步骤</p>
<ul>
<li>如果结点X是链表的结点,则将其重链表中删除.</li>
<li>如果X是该大小的最后一个结点,但是不是叶子结点,它必须用一个叶子结点替换.这里查找叶子结点的方法是从最右侧开始.</li>
<li>如果X是链表的头(拥有parent linker),就需要重新将其x的父结点与替换x的结点重新连接.</li>
</ul>
<div class="codehilite"><pre><span></span><span class="mi">3730</span><span class="err">#</span><span class="n">define</span> <span class="n">unlink_large_chunk</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>\
<span class="mi">3731</span>  <span class="n">tchunkptr</span> <span class="n">XP</span> <span class="o">=</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>\
<span class="mi">3732</span>  <span class="n">tchunkptr</span> <span class="n">R</span><span class="p">;</span>\
</pre></div>


<div class="codehilite"><pre><span></span><span class="mi">3733</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">X</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>\
<span class="mi">3734</span>    <span class="n">tchunkptr</span> <span class="n">F</span> <span class="o">=</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>\
<span class="mi">3735</span>    <span class="n">R</span> <span class="o">=</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>\
<span class="mi">3736</span>    <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">==</span> <span class="n">X</span> <span class="o">&amp;&amp;</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">==</span> <span class="n">X</span><span class="p">))</span> <span class="p">{</span>\
<span class="mi">3737</span>      <span class="n">F</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span>\
<span class="mi">3738</span>      <span class="n">R</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">F</span><span class="p">;</span>\
<span class="mi">3739</span>    <span class="p">}</span>\
<span class="mi">3740</span>    <span class="k">else</span> <span class="p">{</span>\
<span class="mi">3741</span>      <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>\
<span class="mi">3742</span>    <span class="p">}</span>\
<span class="mi">3743</span>  <span class="p">}</span>\
</pre></div>


<p>这里是第一种情况,即x是属于双向链表中的一个结点.</p>
<div class="codehilite"><pre><span></span><span class="mi">3744</span>  <span class="k">else</span> <span class="p">{</span>\
<span class="mi">3745</span>    <span class="n">tchunkptr</span><span class="o">*</span> <span class="n">RP</span><span class="p">;</span>\
<span class="mi">3746</span>    <span class="nf">if</span> <span class="p">(((</span><span class="n">R</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">RP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">X</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>\
<span class="mi">3747</span>        <span class="p">((</span><span class="n">R</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">RP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">X</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>\
<span class="mi">3748</span>      <span class="n">tchunkptr</span><span class="o">*</span> <span class="n">CP</span><span class="p">;</span>\
<span class="mi">3749</span>      <span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">CP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">R</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>\
<span class="mi">3750</span>             <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">CP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">R</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>\
<span class="mi">3751</span>        <span class="n">R</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">RP</span> <span class="o">=</span> <span class="n">CP</span><span class="p">);</span>\
<span class="mi">3752</span>      <span class="p">}</span>\
<span class="mi">3753</span>      <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">RP</span><span class="p">)))</span>\
<span class="mi">3754</span>        <span class="o">*</span><span class="n">RP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>\
<span class="mi">3755</span>      <span class="k">else</span> <span class="p">{</span>\
<span class="mi">3756</span>        <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>\
<span class="mi">3757</span>      <span class="p">}</span>\
<span class="mi">3758</span>    <span class="p">}</span>\
<span class="mi">3759</span>  <span class="p">}</span>\
</pre></div>


<p>这是第二种情况.</p>
<div class="codehilite"><pre><span></span><span class="mi">3760</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">XP</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3761</span>    <span class="n">tbinptr</span><span class="o">*</span> <span class="n">H</span> <span class="o">=</span> <span class="n">treebin_at</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3762</span>    <span class="k">if</span> <span class="p">(</span><span class="n">X</span> <span class="o">==</span> <span class="o">*</span><span class="n">H</span><span class="p">)</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3763</span>      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">H</span> <span class="o">=</span> <span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="err">\</span> 
<span class="mi">3764</span>        <span class="n">clear_treemap</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3765</span>    <span class="p">}</span><span class="err">\</span> 
<span class="mi">3766</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">XP</span><span class="p">)))</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3767</span>      <span class="k">if</span> <span class="p">(</span><span class="n">XP</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">X</span><span class="p">)</span> <span class="err">\</span> 
<span class="mi">3768</span>        <span class="n">XP</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3769</span>      <span class="k">else</span> <span class="err">\</span> 
<span class="mi">3770</span>        <span class="n">XP</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3771</span>    <span class="p">}</span><span class="err">\</span> 
<span class="mi">3772</span>    <span class="k">else</span><span class="err">\</span> 
<span class="mi">3773</span>      <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3774</span>    <span class="k">if</span> <span class="p">(</span><span class="n">R</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3775</span>      <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">R</span><span class="p">)))</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3776</span>        <span class="n">tchunkptr</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3777</span>        <span class="n">R</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">XP</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3778</span>        <span class="k">if</span> <span class="p">((</span><span class="n">C0</span> <span class="o">=</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3779</span>          <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C0</span><span class="p">)))</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3780</span>            <span class="n">R</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">C0</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3781</span>            <span class="n">C0</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3782</span>          <span class="p">}</span><span class="err">\</span> 
<span class="mi">3783</span>          <span class="k">else</span><span class="err">\</span> 
<span class="mi">3784</span>            <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3785</span>        <span class="p">}</span><span class="err">\</span> 
<span class="mi">3786</span>        <span class="k">if</span> <span class="p">((</span><span class="n">C1</span> <span class="o">=</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3787</span>          <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C1</span><span class="p">)))</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3788</span>            <span class="n">R</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C1</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3789</span>            <span class="n">C1</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3790</span>          <span class="p">}</span><span class="err">\</span> 
<span class="mi">3791</span>          <span class="k">else</span><span class="err">\</span> 
<span class="mi">3792</span>            <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3793</span>        <span class="p">}</span><span class="err">\</span> 
<span class="mi">3794</span>      <span class="p">}</span><span class="err">\</span> 
<span class="mi">3795</span>      <span class="k">else</span><span class="err">\</span> 
<span class="mi">3796</span>        <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3797</span>    <span class="p">}</span><span class="err">\</span> 
<span class="mi">3798</span>  <span class="p">}</span><span class="err">\</span> 
</pre></div>


<p>这是第三种情况.
<br></p>
<p>以上,独属于小内存的分配规则结束!</p>
<div class="codehilite"><pre><span></span><span class="mi">4650</span>    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;=</span> <span class="n">MAX_REQUEST</span><span class="p">)</span>
<span class="mi">4651</span>      <span class="n">nb</span> <span class="o">=</span> <span class="n">MAX_SIZE_T</span><span class="p">;</span> <span class="cm">/* Too big to allocate. Force failure (in</span>
<span class="cm">sys alloc) */</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="mi">2224</span><span class="err">#</span><span class="n">define</span> <span class="n">MAX_REQUEST</span>         <span class="p">((</span><span class="o">-</span><span class="p">((</span><span class="n">MCHUNK_SIZE</span> <span class="o">+</span> <span class="n">CHUNK_ALIGN_MASK</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CHUNK_ALIGN_MASK</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>


<p>这里,当请求内存大小&gt;= MAX_REQUEST时,我们强制分配失败.<code>CHUNK_ALIGN_MASK</code> 为 <code>2 * sizeof(void *) - 1</code>,在32bit上为7.所以MAX_REQUEST是一个极大的数.在这种情况下,我们将nb设置为ffffffff,强制失败.</p>
<h3 id="_5">大内存分配规则一<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>类似小内存分配规则一,从树中找到最适合的内存块.</p>
<div class="codehilite"><pre><span></span><span class="mi">4652</span>    <span class="k">else</span> <span class="p">{</span>
<span class="mi">4653</span>      <span class="n">nb</span> <span class="o">=</span> <span class="n">pad_request</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="mi">4654</span>      <span class="nf">if</span> <span class="p">(</span><span class="n">gm</span><span class="o">-&gt;</span><span class="n">treemap</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mem</span> <span class="o">=</span> <span class="n">tmalloc_large</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">nb</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4655</span>        <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4656</span>        <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
<span class="mi">4657</span>      <span class="p">}</span>
<span class="mi">4658</span>    <span class="p">}</span>
</pre></div>


<p>这里我们的重点是<code>tmalloc_large</code>,它与<code>tmalloc_small</code>的差别是:<code>tmalloc_small</code>是用于小内存分配的,只需要在treemap中找到最小的有效树,取出树中最小内存即可;而<code>tmalloc_large</code>是按照一定的规则,在所有32棵树中找到最匹配大小的内存块.</p>
<div class="codehilite"><pre><span></span><span class="mi">4456</span><span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">tmalloc_large</span><span class="p">(</span><span class="n">mstate</span> <span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nb</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4457</span>  <span class="n">tchunkptr</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">4458</span>  <span class="kt">size_t</span> <span class="n">rsize</span> <span class="o">=</span> <span class="o">-</span><span class="n">nb</span><span class="p">;</span> <span class="cm">/* Unsigned negation */</span>
<span class="mi">4459</span>  <span class="n">tchunkptr</span> <span class="n">t</span><span class="p">;</span>
<span class="mi">4460</span>  <span class="n">bindex_t</span> <span class="n">idx</span><span class="p">;</span>
<span class="mi">4461</span>  <span class="n">compute_tree_index</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="mi">4462</span>  <span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">treebin_at</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</pre></div>


<p>rsize 为极大数. <code>compute_tree_index</code>通过请求的大小nb,从treebinmap中计算出箱号.<code>treebin_at</code> 则是取出idx箱号中对应的树根结点.</p>
<div class="codehilite"><pre><span></span><span class="mi">2880</span><span class="err">#</span><span class="n">define</span> <span class="n">compute_tree_index</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>\
<span class="mi">2881</span><span class="p">{</span>\
<span class="mi">2882</span>  <span class="kt">size_t</span> <span class="n">X</span> <span class="o">=</span> <span class="n">S</span> <span class="o">&gt;&gt;</span> <span class="n">TREEBIN_SHIFT</span><span class="p">;</span>\
<span class="mi">2883</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">X</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>\
<span class="mi">2884</span>    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>\
<span class="mi">2885</span>  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">X</span> <span class="o">&gt;</span> <span class="mh">0xFFFF</span><span class="p">)</span>\
<span class="mi">2886</span>    <span class="n">I</span> <span class="o">=</span> <span class="n">NTREEBINS</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>\
<span class="mi">2887</span>  <span class="k">else</span> <span class="p">{</span>\
<span class="mi">2888</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">X</span><span class="p">;</span>\
<span class="mi">2889</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="p">((</span><span class="n">Y</span> <span class="o">-</span> <span class="mh">0x100</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">;</span>\
<span class="mi">2890</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="p">(((</span><span class="n">Y</span> <span class="o">&lt;&lt;=</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">4</span><span class="p">;</span>\
<span class="mi">2891</span>    <span class="n">N</span> <span class="o">+=</span> <span class="n">K</span><span class="p">;</span>\
<span class="mi">2892</span>    <span class="n">N</span> <span class="o">+=</span> <span class="n">K</span> <span class="o">=</span> <span class="p">(((</span><span class="n">Y</span> <span class="o">&lt;&lt;=</span> <span class="n">K</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x4000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">;</span>\
<span class="mi">2893</span>    <span class="n">K</span> <span class="o">=</span> <span class="mi">14</span> <span class="o">-</span> <span class="n">N</span> <span class="o">+</span> <span class="p">((</span><span class="n">Y</span> <span class="o">&lt;&lt;=</span> <span class="n">K</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">15</span><span class="p">);</span>\
<span class="mi">2894</span>    <span class="n">I</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">S</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">K</span> <span class="o">+</span> <span class="p">(</span><span class="n">TREEBIN_SHIFT</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">));</span>\
<span class="mi">2895</span>  <span class="p">}</span>\
<span class="mi">2896</span><span class="p">}</span>
</pre></div>


<p>以上计算的结果如下,idx为对应箱号,mem对应该箱子中最小的内存大小.</p>
<div class="codehilite"><pre><span></span><span class="n">idx</span> <span class="mi">0</span> <span class="n">mem</span> <span class="mi">256</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">100</span>
<span class="n">idx</span> <span class="mi">1</span> <span class="n">mem</span> <span class="mi">384</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">180</span>
<span class="n">idx</span> <span class="mi">2</span> <span class="n">mem</span> <span class="mi">512</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">200</span>
<span class="n">idx</span> <span class="mi">3</span> <span class="n">mem</span> <span class="mi">768</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">300</span>
<span class="n">idx</span> <span class="mi">4</span> <span class="n">mem</span> <span class="mi">1024</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">400</span>
<span class="n">idx</span> <span class="mi">5</span> <span class="n">mem</span> <span class="mi">1536</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">600</span>
<span class="n">idx</span> <span class="mi">6</span> <span class="n">mem</span> <span class="mi">2048</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">800</span>
<span class="n">idx</span> <span class="mi">7</span> <span class="n">mem</span> <span class="mi">3072</span> <span class="n">hex</span><span class="p">:</span> <span class="n">c00</span>
<span class="n">idx</span> <span class="mi">8</span> <span class="n">mem</span> <span class="mi">4096</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">1000</span>
<span class="n">idx</span> <span class="mi">9</span> <span class="n">mem</span> <span class="mi">6144</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">1800</span>
<span class="n">idx</span> <span class="mi">10</span> <span class="n">mem</span> <span class="mi">8192</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">2000</span>
<span class="n">idx</span> <span class="mi">11</span> <span class="n">mem</span> <span class="mi">12288</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">3000</span>
<span class="n">idx</span> <span class="mi">12</span> <span class="n">mem</span> <span class="mi">16384</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">4000</span>
<span class="n">idx</span> <span class="mi">13</span> <span class="n">mem</span> <span class="mi">24576</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">6000</span>
<span class="n">idx</span> <span class="mi">14</span> <span class="n">mem</span> <span class="mi">32768</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">8000</span>
<span class="n">idx</span> <span class="mi">15</span> <span class="n">mem</span> <span class="mi">49152</span> <span class="n">hex</span><span class="p">:</span> <span class="n">c000</span>
<span class="n">idx</span> <span class="mi">16</span> <span class="n">mem</span> <span class="mi">65536</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">10000</span>
<span class="n">idx</span> <span class="mi">17</span> <span class="n">mem</span> <span class="mi">98304</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">18000</span>
<span class="n">idx</span> <span class="mi">18</span> <span class="n">mem</span> <span class="mi">131072</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">20000</span>
<span class="n">idx</span> <span class="mi">19</span> <span class="n">mem</span> <span class="mi">196608</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">30000</span>
<span class="n">idx</span> <span class="mi">20</span> <span class="n">mem</span> <span class="mi">262144</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">40000</span>
<span class="n">idx</span> <span class="mi">21</span> <span class="n">mem</span> <span class="mi">393216</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">60000</span>
<span class="n">idx</span> <span class="mi">22</span> <span class="n">mem</span> <span class="mi">524288</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">80000</span>
<span class="n">idx</span> <span class="mi">23</span> <span class="n">mem</span> <span class="mi">786432</span> <span class="n">hex</span><span class="p">:</span> <span class="n">c0000</span>
<span class="n">idx</span> <span class="mi">24</span> <span class="n">mem</span> <span class="mi">1048576</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">100000</span>
<span class="n">idx</span> <span class="mi">25</span> <span class="n">mem</span> <span class="mi">1572864</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">180000</span>
<span class="n">idx</span> <span class="mi">26</span> <span class="n">mem</span> <span class="mi">2097152</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">200000</span>
<span class="n">idx</span> <span class="mi">27</span> <span class="n">mem</span> <span class="mi">3145728</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">300000</span>
<span class="n">idx</span> <span class="mi">28</span> <span class="n">mem</span> <span class="mi">4194304</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">400000</span>
<span class="n">idx</span> <span class="mi">29</span> <span class="n">mem</span> <span class="mi">6291456</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">600000</span>
<span class="n">idx</span> <span class="mi">30</span> <span class="n">mem</span> <span class="mi">8388608</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">800000</span>
<span class="n">idx</span> <span class="mi">31</span> <span class="n">mem</span> <span class="mi">12582912</span> <span class="n">hex</span><span class="p">:</span> <span class="n">c00000</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="mi">4463</span>    <span class="cm">/* Traverse tree for this bin looking for node with size == nb */</span>
<span class="mi">4464</span>    <span class="kt">size_t</span> <span class="n">sizebits</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">&lt;&lt;</span> <span class="n">leftshift_for_tree_index</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
<span class="mi">4465</span>    <span class="n">tchunkptr</span> <span class="n">rst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* The deepest untaken right subtree */</span>
<span class="mi">4466</span>    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
<span class="mi">4467</span>      <span class="n">tchunkptr</span> <span class="n">rt</span><span class="p">;</span>
<span class="mi">4468</span>      <span class="kt">size_t</span> <span class="n">trem</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
<span class="mi">4469</span>      <span class="nf">if</span> <span class="p">(</span><span class="n">trem</span> <span class="o">&lt;</span> <span class="n">rsize</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4470</span>        <span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="mi">4471</span>        <span class="k">if</span> <span class="p">((</span><span class="n">rsize</span> <span class="o">=</span> <span class="n">trem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">4472</span>          <span class="k">break</span><span class="p">;</span>
<span class="mi">4473</span>      <span class="p">}</span>
<span class="mi">4474</span>      <span class="n">rt</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="mi">4475</span>      <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[(</span><span class="n">sizebits</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">SIZE_T_BITSIZE</span><span class="o">-</span><span class="n">SIZE_T_ONE</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">];</span>
<span class="mi">4476</span>      <span class="nf">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rt</span> <span class="o">!=</span> <span class="n">t</span><span class="p">)</span>
<span class="mi">4477</span>        <span class="n">rst</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
<span class="mi">4478</span>      <span class="nf">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4479</span>        <span class="n">t</span> <span class="o">=</span> <span class="n">rst</span><span class="p">;</span> <span class="cm">/* set t to least subtree holding sizes &gt; nb */</span>
<span class="mi">4480</span>        <span class="k">break</span><span class="p">;</span>
<span class="mi">4481</span>      <span class="p">}</span>
<span class="mi">4482</span>      <span class="n">sizebits</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="mi">4483</span>    <span class="p">}</span>
</pre></div>


<p>这是树的搜索算法,我们来详细看下.首先sizebits变量,类似binmap,每一位对应树的对应深度的左右子树,可以认为是遍历树的key bits.</p>
<div class="codehilite"><pre><span></span><span class="mi">2904</span><span class="err">#</span><span class="n">define</span> <span class="n">leftshift_for_tree_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> \
<span class="mi">2905</span>   <span class="p">((</span><span class="n">i</span> <span class="o">==</span> <span class="n">NTREEBINS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> \
<span class="mi">2906</span>    <span class="p">((</span><span class="n">SIZE_T_BITSIZE</span><span class="o">-</span><span class="n">SIZE_T_ONE</span><span class="p">)</span> <span class="o">-</span> <span class="p">(((</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">TREEBIN_SHIFT</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)))</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="mi">1601</span><span class="err">#</span><span class="n">define</span> <span class="n">SIZE_T_BITSIZE</span>      <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">1606</span><span class="err">#</span><span class="n">define</span> <span class="n">SIZE_T_ONE</span>          <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">2574</span><span class="err">#</span><span class="n">define</span> <span class="n">TREEBIN_SHIFT</span>     <span class="p">(</span><span class="mi">8U</span><span class="p">)</span>
</pre></div>


<p><code>leftshift_for_tree_index</code> 宏将关键码移动到了最左.计算的结果为 (25 - (i &gt;&gt; 1)). 相对于箱子0, 内存范围为128, 关键码长度为 7, <code>leftshift_for_tree_index</code>计算的结果为25. 所以,将 nb &lt;&lt; 25 , 就是将关键码移动到最左端.</p>
<p>然后我们看for循环内部的,这就是在遍历树了.</p>
<div class="codehilite"><pre><span></span><span class="mi">4467</span>      <span class="n">tchunkptr</span> <span class="n">rt</span><span class="p">;</span>
<span class="mi">4468</span>      <span class="kt">size_t</span> <span class="n">trem</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
<span class="mi">4469</span>      <span class="nf">if</span> <span class="p">(</span><span class="n">trem</span> <span class="o">&lt;</span> <span class="n">rsize</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4470</span>        <span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="mi">4471</span>        <span class="k">if</span> <span class="p">((</span><span class="n">rsize</span> <span class="o">=</span> <span class="n">trem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">4472</span>          <span class="k">break</span><span class="p">;</span>
<span class="mi">4473</span>      <span class="p">}</span>
</pre></div>


<p>与 寻找最匹配nb最近的点.当然,如果找到大小相等的,就直接跳出, 这个跳出条件可能是关键码还未搜索完.这里就可以看出, dlmalloc树与 bitwise trie树的差异,值在特征码的路径上的任意点. 为什么可以这么做呢?因为dlmalloc的分箱机制,导致了,如果搜索完关键码,则 该结点必定只存在叶子结点上. 在这个前提下,为了节省内存空间, 在插入结点时,只要在关键码的路径上不存在被占用的点,就将该值插入. 在查看了 <code>insert_large_chunk</code> 后会有更清晰的体会.</p>
<div class="codehilite"><pre><span></span><span class="mi">4474</span>      <span class="n">rt</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="mi">4475</span>      <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[(</span><span class="n">sizebits</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">SIZE_T_BITSIZE</span><span class="o">-</span><span class="n">SIZE_T_ONE</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">];</span>
<span class="mi">4476</span>      <span class="nf">if</span> <span class="p">(</span><span class="n">rt</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rt</span> <span class="o">!=</span> <span class="n">t</span><span class="p">)</span>
<span class="mi">4477</span>        <span class="n">rst</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
<span class="mi">4478</span>      <span class="nf">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4479</span>        <span class="n">t</span> <span class="o">=</span> <span class="n">rst</span><span class="p">;</span> <span class="cm">/* set t to least subtree holding sizes &gt; nb */</span>
<span class="mi">4480</span>        <span class="k">break</span><span class="p">;</span>
<span class="mi">4481</span>      <span class="p">}</span>
<span class="mi">4482</span>      <span class="n">sizebits</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p><code>(sizebits &gt;&gt; (SIZE_T_BITSIZE-SIZE_T_ONE))</code> 这个就是每一层树的特征码了.结合上面sizebits的值,我们可以算出这个表达式的值为 <code>nb &gt;&gt; (6 + (i &gt;&gt; 1))</code>. 如果,我们再结合<code>compute_tree_index</code> 中的结果,得到如下表.idx为箱号,mem为该箱子中的最小内存,hex为该值的16进制,mid为区分左子树和右子树的特征码,bitshift为特征码的无效位数. 比如,箱子1中,dix为1,其表示的内存范围为[384, 512),则其左子树表示范围为[384,448),右子树为[448,512).448即为该树的第一层的特征码,也就是111000000.如果nb &lt; 448, 则第7位为0,否则第7位为1.所以,只要通过将size &gt;&gt; bitshift 之后与1 做位与运算,就可以判断出在该树对应层该进入其左子树还是右子树.</p>
<div class="codehilite"><pre><span></span><span class="n">idx</span> <span class="mi">0</span> <span class="n">mem</span> <span class="mi">256</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">100</span>  <span class="n">mid</span><span class="p">:</span> <span class="mi">101000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">6</span>
<span class="n">idx</span> <span class="mi">1</span> <span class="n">mem</span> <span class="mi">384</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">180</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">111000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">6</span>
<span class="n">idx</span> <span class="mi">2</span> <span class="n">mem</span> <span class="mi">512</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">200</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">1110000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">7</span>
<span class="n">idx</span> <span class="mi">3</span> <span class="n">mem</span> <span class="mi">768</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">300</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">1010000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">7</span>
<span class="n">idx</span> <span class="mi">4</span> <span class="n">mem</span> <span class="mi">1024</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">400</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">10100000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">8</span>
<span class="n">idx</span> <span class="mi">5</span> <span class="n">mem</span> <span class="mi">1536</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">600</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">11100000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">8</span>
<span class="n">idx</span> <span class="mi">6</span> <span class="n">mem</span> <span class="mi">2048</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">800</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">101000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">9</span>
<span class="n">idx</span> <span class="mi">7</span> <span class="n">mem</span> <span class="mi">3072</span> <span class="n">hex</span><span class="p">:</span> <span class="n">c00</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">111000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">9</span>
<span class="n">idx</span> <span class="mi">8</span> <span class="n">mem</span> <span class="mi">4096</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">1000</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">1010000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">10</span>
<span class="n">idx</span> <span class="mi">9</span> <span class="n">mem</span> <span class="mi">6144</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">1800</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">1110000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">10</span>
<span class="n">idx</span> <span class="mi">10</span> <span class="n">mem</span> <span class="mi">8192</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">2000</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">10100000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">11</span>
<span class="n">idx</span> <span class="mi">11</span> <span class="n">mem</span> <span class="mi">12288</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">3000</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">11100000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">11</span>
<span class="n">idx</span> <span class="mi">12</span> <span class="n">mem</span> <span class="mi">16384</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">4000</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">101000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">12</span>
<span class="n">idx</span> <span class="mi">13</span> <span class="n">mem</span> <span class="mi">24576</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">6000</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">111000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">12</span>
<span class="n">idx</span> <span class="mi">14</span> <span class="n">mem</span> <span class="mi">32768</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">8000</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">1010000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">13</span>
<span class="n">idx</span> <span class="mi">15</span> <span class="n">mem</span> <span class="mi">49152</span> <span class="n">hex</span><span class="p">:</span> <span class="n">c000</span> <span class="n">mid</span><span class="p">:</span> <span class="mi">1110000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">13</span>
<span class="n">idx</span> <span class="mi">16</span> <span class="n">mem</span> <span class="mi">65536</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">10000</span> <span class="n">mid</span> <span class="mi">10100000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">14</span>
<span class="n">idx</span> <span class="mi">17</span> <span class="n">mem</span> <span class="mi">98304</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">18000</span> <span class="n">mid</span> <span class="mi">11100000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">14</span>
<span class="n">idx</span> <span class="mi">18</span> <span class="n">mem</span> <span class="mi">131072</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">20000</span> <span class="n">mid</span> <span class="mi">101000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">15</span>
<span class="n">idx</span> <span class="mi">19</span> <span class="n">mem</span> <span class="mi">196608</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">30000</span> <span class="n">mid</span> <span class="mi">111000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">15</span>
<span class="n">idx</span> <span class="mi">20</span> <span class="n">mem</span> <span class="mi">262144</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">40000</span> <span class="n">mid</span> <span class="mi">1010000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">16</span>
<span class="n">idx</span> <span class="mi">21</span> <span class="n">mem</span> <span class="mi">393216</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">60000</span> <span class="n">mid</span> <span class="mi">1110000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">16</span>
<span class="n">idx</span> <span class="mi">22</span> <span class="n">mem</span> <span class="mi">524288</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">80000</span> <span class="n">mid</span> <span class="mi">10100000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">17</span>
<span class="n">idx</span> <span class="mi">23</span> <span class="n">mem</span> <span class="mi">786432</span> <span class="n">hex</span><span class="p">:</span> <span class="n">c0000</span> <span class="n">mid</span> <span class="mi">11100000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">17</span>
<span class="n">idx</span> <span class="mi">24</span> <span class="n">mem</span> <span class="mi">1048576</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">100000</span> <span class="n">mid</span> <span class="mi">101000000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">18</span>
<span class="n">idx</span> <span class="mi">25</span> <span class="n">mem</span> <span class="mi">1572864</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">180000</span> <span class="n">mid</span> <span class="mi">111000000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">18</span>
<span class="n">idx</span> <span class="mi">26</span> <span class="n">mem</span> <span class="mi">2097152</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">200000</span> <span class="n">mid</span> <span class="mi">1010000000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">19</span>
<span class="n">idx</span> <span class="mi">27</span> <span class="n">mem</span> <span class="mi">3145728</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">300000</span> <span class="n">mid</span> <span class="mi">1110000000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">19</span>
<span class="n">idx</span> <span class="mi">28</span> <span class="n">mem</span> <span class="mi">4194304</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">400000</span> <span class="n">mid</span> <span class="mi">10100000000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">20</span>
<span class="n">idx</span> <span class="mi">29</span> <span class="n">mem</span> <span class="mi">6291456</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">600000</span> <span class="n">mid</span> <span class="mi">11100000000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">20</span>
<span class="n">idx</span> <span class="mi">30</span> <span class="n">mem</span> <span class="mi">8388608</span> <span class="n">hex</span><span class="p">:</span> <span class="mi">800000</span> <span class="n">mid</span> <span class="mi">101000000000000000000000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">21</span>
<span class="n">idx</span> <span class="mi">31</span> <span class="n">mem</span> <span class="mi">12582912</span> <span class="n">hex</span><span class="p">:</span> <span class="n">c00000</span> <span class="n">bitshift</span><span class="p">:</span> <span class="mi">31</span>
</pre></div>


<p>// 图, dlammloc 树的图.</p>
<div class="codehilite"><pre><span></span><span class="mi">4485</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* set t to root of next non-empty treebin */</span>
<span class="mi">4486</span>    <span class="n">binmap_t</span> <span class="n">leftbits</span> <span class="o">=</span> <span class="n">left_bits</span><span class="p">(</span><span class="n">idx2bit</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">treemap</span><span class="p">;</span>
<span class="mi">4487</span>    <span class="k">if</span> <span class="p">(</span><span class="n">leftbits</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4488</span>      <span class="n">bindex_t</span> <span class="n">i</span><span class="p">;</span>
<span class="mi">4489</span>      <span class="n">binmap_t</span> <span class="n">leastbit</span> <span class="o">=</span> <span class="n">least_bit</span><span class="p">(</span><span class="n">leftbits</span><span class="p">);</span>
<span class="mi">4490</span>      <span class="n">compute_bit2idx</span><span class="p">(</span><span class="n">leastbit</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="mi">4491</span>      <span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">treebin_at</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="mi">4492</span>    <span class="p">}</span>
<span class="mi">4493</span>  <span class="p">}</span>
</pre></div>


<p>这里对应上文的<code>4462  if ((t = *treebin_at(m, idx)) != 0) {</code> , 也就是说在当前大小的箱子内不存在空闲的内存块,所以我们要把t设置为最近的存在空闲内存块的箱号.<code>left_bits</code> 和 <code>least_bit</code> 跟上文小内存寻找最近存在空闲内存块的箱子算法一样.</p>
<div class="codehilite"><pre><span></span><span class="mi">4495</span>  <span class="nf">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* find smallest of tree or subtree */</span>
<span class="mi">4496</span>    <span class="kt">size_t</span> <span class="n">trem</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
<span class="mi">4497</span>    <span class="k">if</span> <span class="p">(</span><span class="n">trem</span> <span class="o">&lt;</span> <span class="n">rsize</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4498</span>      <span class="n">rsize</span> <span class="o">=</span> <span class="n">trem</span><span class="p">;</span>
<span class="mi">4499</span>      <span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="mi">4500</span>    <span class="p">}</span>
<span class="mi">4501</span>    <span class="n">t</span> <span class="o">=</span> <span class="n">leftmost_child</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="mi">4502</span>  <span class="p">}</span>
</pre></div>


<p>这里跟<code>tmalloc_small</code>寻找最左子树(最小内存)的算法一样.这段代码对上面的两种情况都有效.即,如果在对应箱号有空闲内存,在基于树的搜索算法找到的t就是最匹配nb的大小,所以这里的while循环结果t就不会改变;如果是,寻找最近有空闲块的树,那么该树的最小内存都大于请求大小nb,所以直接寻找最左子树.</p>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/dlmalloc浅析-8.png" /></p>
<div class="codehilite"><pre><span></span><span class="mi">4505</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rsize</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">dvsize</span> <span class="o">-</span> <span class="n">nb</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">4506</span>    <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">)))</span> <span class="p">{</span> <span class="cm">/* split */</span>
<span class="mi">4507</span>      <span class="n">mchunkptr</span> <span class="n">r</span> <span class="o">=</span> <span class="n">chunk_plus_offset</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4508</span>      <span class="n">assert</span><span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">rsize</span> <span class="o">+</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4509</span>      <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_next</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">)))</span> <span class="p">{</span>
<span class="mi">4510</span>        <span class="n">unlink_large_chunk</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="mi">4511</span>        <span class="k">if</span> <span class="p">(</span><span class="n">rsize</span> <span class="o">&lt;</span> <span class="n">MIN_CHUNK_SIZE</span><span class="p">)</span>
<span class="mi">4512</span>          <span class="n">set_inuse_and_pinuse</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">rsize</span> <span class="o">+</span> <span class="n">nb</span><span class="p">));</span>
<span class="mi">4513</span>        <span class="k">else</span> <span class="p">{</span>
<span class="mi">4514</span>          <span class="n">set_size_and_pinuse_of_inuse_chunk</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4515</span>          <span class="n">set_size_and_pinuse_of_free_chunk</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rsize</span><span class="p">);</span>
<span class="mi">4516</span>          <span class="n">insert_chunk</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">rsize</span><span class="p">);</span>
<span class="mi">4517</span>        <span class="p">}</span>
<span class="mi">4518</span>        <span class="k">return</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="mi">4519</span>      <span class="p">}</span>
<span class="mi">4520</span>    <span class="p">}</span>
<span class="mi">4521</span>    <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="mi">4522</span>  <span class="p">}</span>
<span class="mi">4523</span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>接下来,只要求顶找到的内存块比dv chunk更合适,则执行一般的内存块收尾处理,然后返回.如果dv chunk更合适,我们返回0, 参考代码
<code>4654      if (gm-&gt;treemap != 0 &amp;&amp; (mem = tmalloc_large(gm, nb)) != 0) {</code>, 就会继续按照内存分配规则往下走.</p>
<h3 id="_6">大小内存分配规则二<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<p>如果nb的大小 &lt; dv chunk的大小,则使用dv chunk分配内存.尽量保证连续的内存请求在虚拟内存上连续.</p>
<div class="codehilite"><pre><span></span><span class="mi">4660</span>    <span class="nf">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&lt;=</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">dvsize</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4661</span>      <span class="kt">size_t</span> <span class="n">rsize</span> <span class="o">=</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">dvsize</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
<span class="mi">4662</span>      <span class="n">mchunkptr</span> <span class="n">p</span> <span class="o">=</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">dv</span><span class="p">;</span>
<span class="mi">4663</span>      <span class="k">if</span> <span class="p">(</span><span class="n">rsize</span> <span class="o">&gt;=</span> <span class="n">MIN_CHUNK_SIZE</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* split dv */</span>
<span class="mi">4664</span>        <span class="n">mchunkptr</span> <span class="n">r</span> <span class="o">=</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">dv</span> <span class="o">=</span> <span class="n">chunk_plus_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4665</span>        <span class="n">gm</span><span class="o">-&gt;</span><span class="n">dvsize</span> <span class="o">=</span> <span class="n">rsize</span><span class="p">;</span>
<span class="mi">4666</span>        <span class="n">set_size_and_pinuse_of_free_chunk</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rsize</span><span class="p">);</span>
<span class="mi">4667</span>        <span class="n">set_size_and_pinuse_of_inuse_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4668</span>      <span class="p">}</span>
<span class="mi">4669</span>      <span class="k">else</span> <span class="p">{</span> <span class="cm">/* exhaust dv */</span>
<span class="mi">4670</span>        <span class="kt">size_t</span> <span class="n">dvs</span> <span class="o">=</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">dvsize</span><span class="p">;</span>
<span class="mi">4671</span>        <span class="n">gm</span><span class="o">-&gt;</span><span class="n">dvsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">4672</span>        <span class="n">gm</span><span class="o">-&gt;</span><span class="n">dv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">4673</span>        <span class="n">set_inuse_and_pinuse</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dvs</span><span class="p">);</span>
<span class="mi">4674</span>      <span class="p">}</span>
<span class="mi">4675</span>      <span class="n">mem</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="mi">4676</span>      <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4677</span>      <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
<span class="mi">4678</span>    <span class="p">}</span>
</pre></div>


<p>切分dv chunk, 然后就是基本的域设置.返回给用户.</p>
<h3 id="_7">大小内存分配规则四<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><span class="mi">4680</span>    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&lt;</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">topsize</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Split top */</span>
<span class="mi">4681</span>      <span class="kt">size_t</span> <span class="n">rsize</span> <span class="o">=</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">topsize</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">;</span>
<span class="mi">4682</span>      <span class="n">mchunkptr</span> <span class="n">p</span> <span class="o">=</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
<span class="mi">4683</span>      <span class="n">mchunkptr</span> <span class="n">r</span> <span class="o">=</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">chunk_plus_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4684</span>      <span class="n">r</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">rsize</span> <span class="o">|</span> <span class="n">PINUSE_BIT</span><span class="p">;</span>
<span class="mi">4685</span>      <span class="n">set_size_and_pinuse_of_inuse_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4686</span>      <span class="n">mem</span> <span class="o">=</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="mi">4687</span>      <span class="n">check_top_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">gm</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">);</span>
<span class="mi">4688</span>      <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4689</span>      <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
<span class="mi">4690</span>    <span class="p">}</span>
</pre></div>


<p>跟dv chunk类似.难点其实是找到符合的chunk.像dv chunk 和top chunk都是找到了的,就直接分配.</p>
<h3 id="_8">大小内存分配规则五<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p>调用系统函数进行内存分配.这里使用到了segment.</p>
<div class="codehilite"><pre><span></span><span class="mi">4692</span>    <span class="n">mem</span> <span class="o">=</span> <span class="n">sys_alloc</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4693</span>
<span class="mi">4694</span>  <span class="nl">postaction</span><span class="p">:</span>
<span class="mi">4695</span>    <span class="n">POSTACTION</span><span class="p">(</span><span class="n">gm</span><span class="p">);</span>
<span class="mi">4696</span>    <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="mi">4697</span>  <span class="p">}</span>
<span class="mi">4698</span>
<span class="mi">4699</span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>先说下<code>sys_alloc</code>的规则:</p>
<ul>
<li>优先使用MORECORE(sbrk())分配连续的内存空间</li>
<li>使用mmap分配不连续的内存空间</li>
<li>使用sbrk()分配不连续的内存空间.</li>
</ul>
<p>sbrk实际上是对进程的数据段进行扩展,返回增长的区域的基地址.</p>
<div class="codehilite"><pre><span></span><span class="mi">4059</span>  <span class="cm">/* Directly map large chunks, but only if already initialized */</span>
<span class="mi">4060</span>  <span class="k">if</span> <span class="p">(</span><span class="n">use_mmap</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nb</span> <span class="o">&gt;=</span> <span class="n">mparams</span><span class="p">.</span><span class="n">mmap_threshold</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">topsize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4061</span>    <span class="kt">void</span><span class="o">*</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">mmap_alloc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4062</span>    <span class="nf">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">4063</span>      <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="mi">4064</span>  <span class="p">}</span>
</pre></div>


<p>如果使用mmap的标志被置上并且nb &gt;= mmap的阀值,则直接使用mmap.</p>
<div class="codehilite"><pre><span></span><span class="mi">4066</span>  <span class="n">asize</span> <span class="o">=</span> <span class="n">granularity_align</span><span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">SYS_ALLOC_PADDING</span><span class="p">);</span>
</pre></div>


<p>做对齐处理.</p>
<div class="codehilite"><pre><span></span><span class="mi">4105</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">MORECORE_CONTIGUOUS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">use_noncontiguous</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">4106</span>    <span class="kt">char</span><span class="o">*</span> <span class="n">br</span> <span class="o">=</span> <span class="n">CMFAIL</span><span class="p">;</span>
<span class="mi">4107</span>    <span class="kt">size_t</span> <span class="n">ssize</span> <span class="o">=</span> <span class="n">asize</span><span class="p">;</span> <span class="cm">/* sbrk call size */</span>
<span class="mi">4108</span>    <span class="n">msegmentptr</span> <span class="n">ss</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">segment_holding</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">);</span>
<span class="mi">4109</span>    <span class="n">ACQUIRE_MALLOC_GLOBAL_LOCK</span><span class="p">();</span>
</pre></div>


<p>我们看下<code>segment_holding</code>函数.</p>
<div class="codehilite"><pre><span></span><span class="mi">2698</span><span class="k">static</span> <span class="n">msegmentptr</span> <span class="nf">segment_holding</span><span class="p">(</span><span class="n">mstate</span> <span class="n">m</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">2699</span>  <span class="n">msegmentptr</span> <span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">;</span>
<span class="mi">2700</span>  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
<span class="mi">2701</span>    <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
<span class="mi">2702</span>      <span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="mi">2703</span>    <span class="k">if</span> <span class="p">((</span><span class="n">sp</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">2704</span>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">2705</span>  <span class="p">}</span>
<span class="mi">2706</span><span class="p">}</span>
</pre></div>


<p>segment实际上是由单向链表管理的,但由于使用到segment的情况非常少,所以,也没有什么效率问题.
这里的功能就是寻找addr所属的segment块的地址,并返回.结合上面的,ss实际上就是top chunk所在的segment的基地址.</p>
<div class="codehilite"><pre><span></span><span class="mi">4111</span>    <span class="nf">if</span> <span class="p">(</span><span class="n">ss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* First time through or recovery */</span>
<span class="mi">4112</span>      <span class="kt">char</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">CALL_MORECORE</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="mi">4113</span>      <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">!=</span> <span class="n">CMFAIL</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4114</span>        <span class="kt">size_t</span> <span class="n">fp</span><span class="p">;</span>
<span class="mi">4115</span>        <span class="cm">/* Adjust to end on a page boundary */</span>
<span class="mi">4116</span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_page_aligned</span><span class="p">(</span><span class="n">base</span><span class="p">))</span>
<span class="mi">4117</span>          <span class="n">ssize</span> <span class="o">+=</span> <span class="p">(</span><span class="n">page_align</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">base</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">base</span><span class="p">);</span>
<span class="mi">4118</span>        <span class="n">fp</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">footprint</span> <span class="o">+</span> <span class="n">ssize</span><span class="p">;</span> <span class="cm">/* recheck limits */</span>
<span class="mi">4119</span>        <span class="k">if</span> <span class="p">(</span><span class="n">ssize</span> <span class="o">&gt;</span> <span class="n">nb</span> <span class="o">&amp;&amp;</span> <span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">HALF_MAX_SIZE_T</span> <span class="o">&amp;&amp;</span>
<span class="mi">4120</span>            <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">footprint_limit</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
<span class="mi">4121</span>             <span class="p">(</span><span class="n">fp</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">footprint</span> <span class="o">&amp;&amp;</span> <span class="n">fp</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">footprint_limit</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
<span class="mi">4122</span>            <span class="p">(</span><span class="n">br</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">CALL_MORECORE</span><span class="p">(</span><span class="n">ssize</span><span class="p">)))</span> <span class="o">==</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4123</span>          <span class="n">tbase</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
<span class="mi">4124</span>          <span class="n">tsize</span> <span class="o">=</span> <span class="n">ssize</span><span class="p">;</span>
<span class="mi">4125</span>        <span class="p">}</span>
<span class="mi">4126</span>      <span class="p">}</span>
<span class="mi">4127</span>    <span class="p">}</span>
</pre></div>


<p>这里就是处理top chunk为NULL 时的情况, 也就是第一次请求内存分配,因为top为0.<code>CALL_MORECORE</code>宏展开来就是<code>sbrk</code>.这里是获取当前的program break的地址.
ssize就是请求增加的大小,然后再次调用sbrk.</p>
<div class="codehilite"><pre><span></span><span class="mi">4128</span>    <span class="k">else</span> <span class="p">{</span>
<span class="mi">4129</span>      <span class="cm">/* Subtract out existing available top space from MORECORE request. */</span>
<span class="mi">4130</span>      <span class="n">ssize</span> <span class="o">=</span> <span class="n">granularity_align</span><span class="p">(</span><span class="n">nb</span> <span class="o">-</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">topsize</span> <span class="o">+</span> <span class="n">SYS_ALLOC_PADDING</span><span class="p">);</span>
<span class="mi">4131</span>      <span class="cm">/* Use mem here only if it did continuously extend old space */</span>
<span class="mi">4132</span>      <span class="k">if</span> <span class="p">(</span><span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">HALF_MAX_SIZE_T</span> <span class="o">&amp;&amp;</span>
<span class="mi">4133</span>          <span class="p">(</span><span class="n">br</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">CALL_MORECORE</span><span class="p">(</span><span class="n">ssize</span><span class="p">)))</span> <span class="o">==</span> <span class="n">ss</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">+</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4134</span>        <span class="n">tbase</span> <span class="o">=</span> <span class="n">br</span><span class="p">;</span>
<span class="mi">4135</span>        <span class="n">tsize</span> <span class="o">=</span> <span class="n">ssize</span><span class="p">;</span>
<span class="mi">4136</span>      <span class="p">}</span>
<span class="mi">4137</span>    <span class="p">}</span>
</pre></div>


<p>对应top chunk 存在的情况.直接扩展top chunk所在的segment.
上面两种情况的tbase都指向增长的块的基地址,tsize指向增长的大小.</p>
<div class="codehilite"><pre><span></span><span class="mi">4139</span>    <span class="nf">if</span> <span class="p">(</span><span class="n">tbase</span> <span class="o">==</span> <span class="n">CMFAIL</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* Cope with partial failure */</span>
<span class="mi">4140</span>      <span class="k">if</span> <span class="p">(</span><span class="n">br</span> <span class="o">!=</span> <span class="n">CMFAIL</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* Try to use/extend the space we did get */</span>
<span class="mi">4141</span>        <span class="k">if</span> <span class="p">(</span><span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">HALF_MAX_SIZE_T</span> <span class="o">&amp;&amp;</span>
<span class="mi">4142</span>            <span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">nb</span> <span class="o">+</span> <span class="n">SYS_ALLOC_PADDING</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4143</span>          <span class="kt">size_t</span> <span class="n">esize</span> <span class="o">=</span> <span class="n">granularity_align</span><span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">SYS_ALLOC_PADDING</span> <span class="o">-</span> <span class="n">ssize</span><span class="p">);</span>
<span class="mi">4144</span>          <span class="k">if</span> <span class="p">(</span><span class="n">esize</span> <span class="o">&lt;</span> <span class="n">HALF_MAX_SIZE_T</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4145</span>            <span class="kt">char</span><span class="o">*</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">CALL_MORECORE</span><span class="p">(</span><span class="n">esize</span><span class="p">);</span>
<span class="mi">4146</span>            <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="n">CMFAIL</span><span class="p">)</span>
<span class="mi">4147</span>              <span class="n">ssize</span> <span class="o">+=</span> <span class="n">esize</span><span class="p">;</span>
<span class="mi">4148</span>            <span class="k">else</span> <span class="p">{</span>            <span class="cm">/* Can&#39;t use; try to release */</span>
<span class="mi">4149</span>              <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">CALL_MORECORE</span><span class="p">(</span><span class="o">-</span><span class="n">ssize</span><span class="p">);</span>
<span class="mi">4150</span>              <span class="n">br</span> <span class="o">=</span> <span class="n">CMFAIL</span><span class="p">;</span>
<span class="mi">4151</span>            <span class="p">}</span>
<span class="mi">4152</span>          <span class="p">}</span>
<span class="mi">4153</span>        <span class="p">}</span>
<span class="mi">4154</span>      <span class="p">}</span>
<span class="mi">4155</span>      <span class="k">if</span> <span class="p">(</span><span class="n">br</span> <span class="o">!=</span> <span class="n">CMFAIL</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* Use the space we did get */</span>
<span class="mi">4156</span>        <span class="n">tbase</span> <span class="o">=</span> <span class="n">br</span><span class="p">;</span>
<span class="mi">4157</span>        <span class="n">tsize</span> <span class="o">=</span> <span class="n">ssize</span><span class="p">;</span>
<span class="mi">4158</span>      <span class="p">}</span>
<span class="mi">4159</span>      <span class="k">else</span>
<span class="mi">4160</span>        <span class="n">disable_contiguous</span><span class="p">(</span><span class="n">m</span><span class="p">);</span> <span class="cm">/* Don&#39;t try contiguous path in the future */</span>
<span class="mi">4161</span>    <span class="p">}</span>
<span class="mi">4162</span>
<span class="mi">4163</span>    <span class="nf">RELEASE_MALLOC_GLOBAL_LOCK</span><span class="p">();</span>
</pre></div>


<p>如果部分失败了,即上文的tbase赋值时,if条件部分不满,也就是,请求的ssize &gt; HALF_MAX_SIZE_T(ffffffff/2)或者其他的情况.则我们继续使用br的地址进行扩展.不过一般情况下tbase == CMFAIL 时, br == CFAIL.从这部分的代码逻辑看,应该是非连续的sbrk的逻辑.</p>
<div class="codehilite"><pre><span></span><span class="mi">4166</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">HAVE_MMAP</span> <span class="o">&amp;&amp;</span> <span class="n">tbase</span> <span class="o">==</span> <span class="n">CMFAIL</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* Try MMAP */</span>
<span class="mi">4167</span>    <span class="kt">char</span><span class="o">*</span> <span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">CALL_MMAP</span><span class="p">(</span><span class="n">asize</span><span class="p">));</span>
<span class="mi">4168</span>    <span class="k">if</span> <span class="p">(</span><span class="n">mp</span> <span class="o">!=</span> <span class="n">CMFAIL</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4169</span>      <span class="n">tbase</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
<span class="mi">4170</span>      <span class="n">tsize</span> <span class="o">=</span> <span class="n">asize</span><span class="p">;</span>
<span class="mi">4171</span>      <span class="n">mmap_flag</span> <span class="o">=</span> <span class="n">USE_MMAP_BIT</span><span class="p">;</span>
<span class="mi">4172</span>    <span class="p">}</span>
<span class="mi">4173</span>  <span class="p">}</span>
</pre></div>


<p>尝试 mmap.</p>
<div class="codehilite"><pre><span></span><span class="mi">4175</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">HAVE_MORECORE</span> <span class="o">&amp;&amp;</span> <span class="n">tbase</span> <span class="o">==</span> <span class="n">CMFAIL</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Try noncontiguous MORECORE */</span>
<span class="mi">4176</span>    <span class="k">if</span> <span class="p">(</span><span class="n">asize</span> <span class="o">&lt;</span> <span class="n">HALF_MAX_SIZE_T</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4177</span>      <span class="kt">char</span><span class="o">*</span> <span class="n">br</span> <span class="o">=</span> <span class="n">CMFAIL</span><span class="p">;</span>
<span class="mi">4178</span>      <span class="kt">char</span><span class="o">*</span> <span class="n">end</span> <span class="o">=</span> <span class="n">CMFAIL</span><span class="p">;</span>
<span class="mi">4179</span>      <span class="n">ACQUIRE_MALLOC_GLOBAL_LOCK</span><span class="p">();</span>
<span class="mi">4180</span>      <span class="n">br</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">CALL_MORECORE</span><span class="p">(</span><span class="n">asize</span><span class="p">));</span>
<span class="mi">4181</span>      <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">CALL_MORECORE</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="mi">4182</span>      <span class="n">RELEASE_MALLOC_GLOBAL_LOCK</span><span class="p">();</span>
<span class="mi">4183</span>      <span class="k">if</span> <span class="p">(</span><span class="n">br</span> <span class="o">!=</span> <span class="n">CMFAIL</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">!=</span> <span class="n">CMFAIL</span> <span class="o">&amp;&amp;</span> <span class="n">br</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4184</span>        <span class="kt">size_t</span> <span class="n">ssize</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">br</span><span class="p">;</span>
<span class="mi">4185</span>        <span class="k">if</span> <span class="p">(</span><span class="n">ssize</span> <span class="o">&gt;</span> <span class="n">nb</span> <span class="o">+</span> <span class="n">TOP_FOOT_SIZE</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4186</span>          <span class="n">tbase</span> <span class="o">=</span> <span class="n">br</span><span class="p">;</span>
<span class="mi">4187</span>          <span class="n">tsize</span> <span class="o">=</span> <span class="n">ssize</span><span class="p">;</span>
<span class="mi">4188</span>        <span class="p">}</span>
<span class="mi">4189</span>      <span class="p">}</span>
<span class="mi">4190</span>    <span class="p">}</span>
<span class="mi">4191</span>  <span class="p">}</span>
</pre></div>


<p>尝试非连续的sbrk.</p>
<div class="codehilite"><pre><span></span><span class="mi">4198</span>    <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_initialized</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* first-time initialization */</span>
<span class="mi">4199</span>      <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">least_addr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tbase</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">least_addr</span><span class="p">)</span>
<span class="mi">4200</span>        <span class="n">m</span><span class="o">-&gt;</span><span class="n">least_addr</span> <span class="o">=</span> <span class="n">tbase</span><span class="p">;</span>
<span class="mi">4201</span>      <span class="n">m</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">tbase</span><span class="p">;</span>
<span class="mi">4202</span>      <span class="n">m</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">tsize</span><span class="p">;</span>
<span class="mi">4203</span>      <span class="n">m</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">.</span><span class="n">sflags</span> <span class="o">=</span> <span class="n">mmap_flag</span><span class="p">;</span>
<span class="mi">4204</span>      <span class="n">m</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">mparams</span><span class="p">.</span><span class="n">magic</span><span class="p">;</span>
<span class="mi">4205</span>      <span class="n">m</span><span class="o">-&gt;</span><span class="n">release_checks</span> <span class="o">=</span> <span class="n">MAX_RELEASE_CHECK_RATE</span><span class="p">;</span>
          <span class="c1">// 初始化 所有的箱子. 32bit全置0</span>
<span class="mi">4206</span>      <span class="n">init_bins</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="mi">4207</span><span class="err">#</span><span class="k">if</span> <span class="o">!</span><span class="n">ONLY_MSPACES</span>
<span class="mi">4208</span>      <span class="k">if</span> <span class="p">(</span><span class="n">is_global</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
            <span class="c1">// 初始化top chunk.</span>
<span class="mi">4209</span>        <span class="n">init_top</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="n">mchunkptr</span><span class="p">)</span><span class="n">tbase</span><span class="p">,</span> <span class="n">tsize</span> <span class="o">-</span> <span class="n">TOP_FOOT_SIZE</span><span class="p">);</span>
<span class="mi">4210</span>      <span class="k">else</span>
<span class="mi">4211</span><span class="err">#</span><span class="n">endif</span>
<span class="mi">4212</span>      <span class="p">{</span>
<span class="mi">4213</span>        <span class="cm">/* Offset top by embedded malloc_state */</span>
<span class="mi">4214</span>        <span class="n">mchunkptr</span> <span class="n">mn</span> <span class="o">=</span> <span class="n">next_chunk</span><span class="p">(</span><span class="n">mem2chunk</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>
            <span class="c1">// 初始化top chunk.</span>
<span class="mi">4215</span>        <span class="n">init_top</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)((</span><span class="n">tbase</span> <span class="o">+</span> <span class="n">tsize</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">mn</span><span class="p">)</span> <span class="o">-</span><span class="n">TOP_FOOT_SIZE</span><span class="p">);</span>
<span class="mi">4216</span>      <span class="p">}</span>
<span class="mi">4217</span>    <span class="p">}</span>
</pre></div>


<p>在这里,才是真正地对内存管理的一些结构体进行初始化.</p>
<div class="codehilite"><pre><span></span><span class="mi">4219</span>    <span class="k">else</span> <span class="p">{</span>
<span class="mi">4220</span>      <span class="cm">/* Try to merge with an existing segment */</span>
<span class="mi">4221</span>      <span class="n">msegmentptr</span> <span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">;</span>
<span class="mi">4222</span>      <span class="cm">/* Only consider most recent segment if traversal suppressed */</span>
<span class="mi">4223</span>      <span class="k">while</span> <span class="p">(</span><span class="n">sp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tbase</span> <span class="o">!=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
<span class="mi">4224</span>        <span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">NO_SEGMENT_TRAVERSAL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="mi">4225</span>      <span class="nf">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
<span class="mi">4226</span>          <span class="o">!</span><span class="n">is_extern_segment</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="mi">4227</span>          <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sflags</span> <span class="o">&amp;</span> <span class="n">USE_MMAP_BIT</span><span class="p">)</span> <span class="o">==</span> <span class="n">mmap_flag</span> <span class="o">&amp;&amp;</span>
<span class="mi">4228</span>          <span class="n">segment_holds</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* append */</span>
<span class="mi">4229</span>        <span class="n">sp</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">tsize</span><span class="p">;</span>
<span class="mi">4230</span>        <span class="n">init_top</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">topsize</span> <span class="o">+</span> <span class="n">tsize</span><span class="p">);</span>
<span class="mi">4231</span>      <span class="p">}</span>
<span class="mi">4232</span>      <span class="k">else</span> <span class="p">{</span>
<span class="mi">4233</span>        <span class="k">if</span> <span class="p">(</span><span class="n">tbase</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">least_addr</span><span class="p">)</span>
<span class="mi">4234</span>          <span class="n">m</span><span class="o">-&gt;</span><span class="n">least_addr</span> <span class="o">=</span> <span class="n">tbase</span><span class="p">;</span>
<span class="mi">4235</span>        <span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">seg</span><span class="p">;</span>
<span class="mi">4236</span>        <span class="nf">while</span> <span class="p">(</span><span class="n">sp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">!=</span> <span class="n">tbase</span> <span class="o">+</span> <span class="n">tsize</span><span class="p">)</span>
<span class="mi">4237</span>          <span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">NO_SEGMENT_TRAVERSAL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="mi">4238</span>        <span class="nf">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
<span class="mi">4239</span>            <span class="o">!</span><span class="n">is_extern_segment</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<span class="mi">4240</span>            <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">sflags</span> <span class="o">&amp;</span> <span class="n">USE_MMAP_BIT</span><span class="p">)</span> <span class="o">==</span> <span class="n">mmap_flag</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4241</span>          <span class="kt">char</span><span class="o">*</span> <span class="n">oldbase</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
<span class="mi">4242</span>          <span class="n">sp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">tbase</span><span class="p">;</span>
<span class="mi">4243</span>          <span class="n">sp</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">tsize</span><span class="p">;</span>
<span class="mi">4244</span>          <span class="k">return</span> <span class="n">prepend_alloc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tbase</span><span class="p">,</span> <span class="n">oldbase</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4245</span>        <span class="p">}</span>
<span class="mi">4246</span>        <span class="k">else</span>
<span class="mi">4247</span>          <span class="nf">add_segment</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">tbase</span><span class="p">,</span> <span class="n">tsize</span><span class="p">,</span> <span class="n">mmap_flag</span><span class="p">);</span>
<span class="mi">4248</span>      <span class="p">}</span>
<span class="mi">4249</span>    <span class="p">}</span>
</pre></div>


<p>逻辑很简单,就是如果新分配的segemnt的基地址是某个segment的尾地址,则这两个合并,否则,直接将该新的segment加入到单向链表中.</p>
<div class="codehilite"><pre><span></span><span class="mi">4251</span>    <span class="nf">if</span> <span class="p">(</span><span class="n">nb</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">topsize</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Allocate from new or extended top space */</span>
<span class="mi">4252</span>      <span class="kt">size_t</span> <span class="n">rsize</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">topsize</span> <span class="o">-=</span> <span class="n">nb</span><span class="p">;</span>
<span class="mi">4253</span>      <span class="n">mchunkptr</span> <span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
<span class="mi">4254</span>      <span class="n">mchunkptr</span> <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">chunk_plus_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4255</span>      <span class="n">r</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">rsize</span> <span class="o">|</span> <span class="n">PINUSE_BIT</span><span class="p">;</span>
<span class="mi">4256</span>      <span class="n">set_size_and_pinuse_of_inuse_chunk</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4257</span>      <span class="n">check_top_chunk</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">);</span>
<span class="mi">4258</span>      <span class="n">check_malloced_chunk</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">nb</span><span class="p">);</span>
<span class="mi">4259</span>      <span class="k">return</span> <span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="mi">4260</span>    <span class="p">}</span>
<span class="mi">4261</span>  <span class="p">}</span>
</pre></div>


<p>如果是第一次内存分配,则逻辑将会到这里,在top chunk初始化后,尝试从top chunk分配内存.</p>
<h2 id="dlfree">dlfree代码分析<a class="headerlink" href="#dlfree" title="Permanent link">&para;</a></h2>
<p>dlfree就没有dlmalloc那么多规则了,只要保证边界标记法,保证释放的内存块存放到对应的箱子中即可.</p>
<div class="codehilite"><pre><span></span><span class="mi">4704</span><span class="kt">void</span> <span class="nf">dlfree</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">mem</span><span class="p">)</span> <span class="p">{</span> 
<span class="mi">4711</span>  <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</pre></div>


<p>检查mem合法性.</p>
<div class="codehilite"><pre><span></span><span class="mi">4711</span>  <span class="nf">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//将mem转换成chunk p</span>
<span class="mi">4712</span>    <span class="n">mchunkptr</span> <span class="n">p</span>  <span class="o">=</span> <span class="n">mem2chunk</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
<span class="mi">4713</span><span class="err">#</span><span class="k">if</span> <span class="n">FOOTERS</span>
<span class="mi">4714</span>    <span class="n">mstate</span> <span class="n">fm</span> <span class="o">=</span> <span class="n">get_mstate_for</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="mi">4715</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok_magic</span><span class="p">(</span><span class="n">fm</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">4716</span>      <span class="n">USAGE_ERROR_ACTION</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="mi">4717</span>      <span class="k">return</span><span class="p">;</span>
<span class="mi">4718</span>    <span class="p">}</span>
<span class="mi">4719</span><span class="err">#</span><span class="k">else</span> <span class="cm">/* FOOTERS */</span>
<span class="mi">4720</span><span class="err">#</span><span class="n">define</span> <span class="n">fm</span> <span class="n">gm</span>
<span class="mi">4721</span><span class="err">#</span><span class="n">endif</span> <span class="cm">/* FOOTERS */</span> 
<span class="mi">4722</span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PREACTION</span><span class="p">(</span><span class="n">fm</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// 检查标志位是否为inuse.</span>
<span class="mi">4723</span>      <span class="n">check_inuse_chunk</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="mi">4724</span>      <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ok_inuse</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
            <span class="c1">// 获取chunksize</span>
<span class="mi">4725</span>        <span class="kt">size_t</span> <span class="n">psize</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="c1">// 获取在内存上相连的下一个内存chunk.</span>
<span class="mi">4726</span>        <span class="n">mchunkptr</span> <span class="n">next</span> <span class="o">=</span> <span class="n">chunk_plus_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">psize</span><span class="p">);</span> 
</pre></div>


<p>将用户指针转换为chunk结构体并做常规检查.</p>
<div class="codehilite"><pre><span></span>            <span class="c1">// 上一个内存块未被使用</span>
<span class="mi">4727</span>        <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinuse</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
<span class="mi">4728</span>          <span class="kt">size_t</span> <span class="n">prevsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prev_foot</span><span class="p">;</span>
<span class="mi">4729</span>          <span class="k">if</span> <span class="p">(</span><span class="n">is_mmapped</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 是通过系统mmap分配的</span>
<span class="mi">4730</span>            <span class="n">psize</span> <span class="o">+=</span> <span class="n">prevsize</span> <span class="o">+</span> <span class="n">MMAP_FOOT_PAD</span><span class="p">;</span>
<span class="mi">4731</span>            <span class="k">if</span> <span class="p">(</span><span class="n">CALL_MUNMAP</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">-</span> <span class="n">prevsize</span><span class="p">,</span> <span class="n">psize</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">4732</span>              <span class="n">fm</span><span class="o">-&gt;</span><span class="n">footprint</span> <span class="o">-=</span> <span class="n">psize</span><span class="p">;</span>
<span class="mi">4733</span>            <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
<span class="mi">4734</span>          <span class="p">}</span>
<span class="mi">4735</span>          <span class="k">else</span> <span class="p">{</span>
               <span class="c1">// 与上一个内存块合并</span>
<span class="mi">4736</span>            <span class="n">mchunkptr</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">chunk_minus_offset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prevsize</span><span class="p">);</span>
<span class="mi">4737</span>            <span class="n">psize</span> <span class="o">+=</span> <span class="n">prevsize</span><span class="p">;</span>
<span class="mi">4738</span>            <span class="n">p</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
<span class="mi">4739</span>            <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">prev</span><span class="p">)))</span> <span class="p">{</span> <span class="cm">/* consolidate backward */</span>
<span class="mi">4740</span>              <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dv</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// p 不为 dv chunk, 直接移除.</span>
<span class="mi">4741</span>                <span class="n">unlink_chunk</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">prevsize</span><span class="p">);</span>
<span class="mi">4742</span>              <span class="p">}</span>
<span class="mi">4743</span>              <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">&amp;</span> <span class="n">INUSE_BITS</span><span class="p">)</span> <span class="o">==</span> <span class="n">INUSE_BITS</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 否则,合并到dv chunk中.</span>
<span class="mi">4744</span>                <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dvsize</span> <span class="o">=</span> <span class="n">psize</span><span class="p">;</span>
<span class="mi">4745</span>                <span class="n">set_free_with_pinuse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="mi">4746</span>                <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
<span class="mi">4747</span>              <span class="p">}</span>
<span class="mi">4748</span>            <span class="p">}</span>
<span class="mi">4749</span>            <span class="k">else</span>
<span class="mi">4750</span>              <span class="k">goto</span> <span class="n">erroraction</span><span class="p">;</span>
<span class="mi">4751</span>          <span class="p">}</span>
<span class="mi">4752</span>        <span class="p">}</span> 
</pre></div>


<p>与前一块内存合并的逻辑.</p>
<div class="codehilite"><pre><span></span><span class="mi">4754</span>        <span class="nf">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_next</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ok_pinuse</span><span class="p">(</span><span class="n">next</span><span class="p">)))</span> <span class="p">{</span>
</pre></div>


<p>ok_pinuse(next)实际上就是cinuse(p). 只是这里是检查next的标志位是否正确.</p>
<div class="codehilite"><pre><span></span>              <span class="c1">// next 未被使用, 则需要合并.</span>
<span class="mi">4755</span>          <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cinuse</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>  <span class="cm">/* consolidate forward */</span>
<span class="mi">4756</span>            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">fm</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// 如果next为top, 则top增长.基地址改为p.</span>
<span class="mi">4757</span>              <span class="kt">size_t</span> <span class="n">tsize</span> <span class="o">=</span> <span class="n">fm</span><span class="o">-&gt;</span><span class="n">topsize</span> <span class="o">+=</span> <span class="n">psize</span><span class="p">;</span>
<span class="mi">4758</span>              <span class="n">fm</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="mi">4759</span>              <span class="n">p</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">tsize</span> <span class="o">|</span> <span class="n">PINUSE_BIT</span><span class="p">;</span>
<span class="mi">4760</span>              <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dv</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 如果p为dv, 则清空dv.</span>
<span class="mi">4761</span>                <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">4762</span>                <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dvsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">4763</span>              <span class="p">}</span>
                  <span class="c1">// 检查top chunk的大小是否需要调整,默认最大为 2 * 1024 * 1024</span>
<span class="mi">4764</span>              <span class="k">if</span> <span class="p">(</span><span class="n">should_trim</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">tsize</span><span class="p">))</span>
<span class="mi">4765</span>                <span class="n">sys_trim</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="mi">4766</span>              <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
<span class="mi">4767</span>            <span class="p">}</span>
<span class="mi">4768</span>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dv</span><span class="p">)</span> <span class="p">{</span>
                  <span class="c1">// 如果next为div, 则dv增长, 基地址改为p</span>
<span class="mi">4769</span>              <span class="kt">size_t</span> <span class="n">dsize</span> <span class="o">=</span> <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dvsize</span> <span class="o">+=</span> <span class="n">psize</span><span class="p">;</span>
<span class="mi">4770</span>              <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dv</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
<span class="mi">4771</span>              <span class="n">set_size_and_pinuse_of_free_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dsize</span><span class="p">);</span>
<span class="mi">4772</span>              <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
<span class="mi">4773</span>            <span class="p">}</span>
<span class="mi">4774</span>            <span class="k">else</span> <span class="p">{</span>
                  <span class="c1">// next为普通的内存块,将next合并到p,并将next冲链表或者树中删除.</span>
<span class="mi">4775</span>              <span class="kt">size_t</span> <span class="n">nsize</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="mi">4776</span>              <span class="n">psize</span> <span class="o">+=</span> <span class="n">nsize</span><span class="p">;</span>
<span class="mi">4777</span>              <span class="n">unlink_chunk</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">nsize</span><span class="p">);</span>
<span class="mi">4778</span>              <span class="n">set_size_and_pinuse_of_free_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">psize</span><span class="p">);</span>
<span class="mi">4779</span>              <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dv</span><span class="p">)</span> <span class="p">{</span>
<span class="mi">4780</span>                <span class="n">fm</span><span class="o">-&gt;</span><span class="n">dvsize</span> <span class="o">=</span> <span class="n">psize</span><span class="p">;</span>
<span class="mi">4781</span>                <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
<span class="mi">4782</span>              <span class="p">}</span>
<span class="mi">4783</span>            <span class="p">}</span>
              <span class="c1">// 与后一块内存合并的逻辑.</span>
<span class="mi">4785</span>          <span class="k">else</span>
<span class="mi">4786</span>            <span class="n">set_free_with_pinuse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
</pre></div>


<p>当然,如果不需要合并,则直接删除.</p>
<p>以上都只是合并块,并删除被合并的结点,接下来就是将合并后的块插入到正确的箱子的结构中.</p>
<div class="codehilite"><pre><span></span><span class="mi">4788</span>          <span class="nf">if</span> <span class="p">(</span><span class="n">is_small</span><span class="p">(</span><span class="n">psize</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 合并处理后的内存为小内存</span>
                <span class="c1">// 已在上文介绍过该函数.</span>
<span class="mi">4789</span>            <span class="n">insert_small_chunk</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">psize</span><span class="p">);</span>
<span class="mi">4790</span>            <span class="n">check_free_chunk</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="mi">4791</span>          <span class="p">}</span>
<span class="mi">4792</span>          <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 合并后为大内存</span>
<span class="mi">4793</span>            <span class="n">tchunkptr</span> <span class="n">tp</span> <span class="o">=</span> <span class="p">(</span><span class="n">tchunkptr</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
<span class="mi">4794</span>            <span class="nf">insert_large_chunk</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">psize</span><span class="p">);</span>
<span class="mi">4795</span>            <span class="nf">check_free_chunk</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="mi">4796</span>            <span class="nf">if</span> <span class="p">(</span><span class="o">--</span><span class="n">fm</span><span class="o">-&gt;</span><span class="n">release_checks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">4797</span>              <span class="n">release_unused_segments</span><span class="p">(</span><span class="n">fm</span><span class="p">);</span>
<span class="mi">4798</span>          <span class="p">}</span>
<span class="mi">4799</span>          <span class="k">goto</span> <span class="n">postaction</span><span class="p">;</span>
<span class="mi">4800</span>        <span class="p">}</span>
<span class="mi">4801</span>      <span class="p">}</span>
<span class="mi">4802</span>    <span class="nl">erroraction</span><span class="p">:</span>
<span class="mi">4803</span>      <span class="n">USAGE_ERROR_ACTION</span><span class="p">(</span><span class="n">fm</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="mi">4804</span>    <span class="nl">postaction</span><span class="p">:</span>
<span class="mi">4805</span>      <span class="n">POSTACTION</span><span class="p">(</span><span class="n">fm</span><span class="p">);</span>
<span class="mi">4806</span>    <span class="p">}</span>
<span class="mi">4807</span>  <span class="p">}</span>  
</pre></div>


<p><code>insert_small_chunk</code> 已经在上文介绍过.实际行为就是根据内存大小找箱号,如果该箱子本身为空,则修改binmap状态并插入该chunk.如果不为空,则执行双向链表插入.
而<code>insert_large_chunk</code>是我们之前提到的<code>unlink_large_chunk</code>的逆操作.同样是定位箱号,遍历树.然后找到对应该大小的结点.它存在以下两种情况:</p>
<ul>
<li>该箱子中不存在树. 则创建并将该结点作为根节点.</li>
<li>已存在树,但不存在对应大小的结点, 则插入结点.</li>
<li>已存在树,且存在对应大小的结点,则插入双向链表</li>
</ul>
<div class="codehilite"><pre><span></span><span class="mi">3662</span><span class="err">#</span><span class="n">define</span> <span class="n">insert_large_chunk</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3663</span>  <span class="n">tbinptr</span><span class="o">*</span> <span class="n">H</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3664</span>  <span class="n">bindex_t</span> <span class="n">I</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3665</span>  <span class="n">compute_tree_index</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3666</span>  <span class="n">H</span> <span class="o">=</span> <span class="n">treebin_at</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3667</span>  <span class="n">X</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3668</span>  <span class="n">X</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3669</span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">treemap_is_marked</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">I</span><span class="p">))</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3670</span>    <span class="n">mark_treemap</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3671</span>    <span class="o">*</span><span class="n">H</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3672</span>    <span class="n">X</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">tchunkptr</span><span class="p">)</span><span class="n">H</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3673</span>    <span class="n">X</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3674</span>  <span class="p">}</span>\

<span class="c1">//上面为情况一. 将treemap 对应I的位置置1,并将该结点作为树的根结点.</span>

<span class="mi">3675</span>  <span class="k">else</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3676</span>    <span class="n">tchunkptr</span> <span class="n">T</span> <span class="o">=</span> <span class="o">*</span><span class="n">H</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3677</span>    <span class="kt">size_t</span> <span class="n">K</span> <span class="o">=</span> <span class="n">S</span> <span class="o">&lt;&lt;</span> <span class="n">leftshift_for_tree_index</span><span class="p">(</span><span class="n">I</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3678</span>    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3679</span>      <span class="k">if</span> <span class="p">(</span><span class="n">chunksize</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">!=</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3680</span>        <span class="n">tchunkptr</span><span class="o">*</span> <span class="n">C</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[(</span><span class="n">K</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">SIZE_T_BITSIZE</span><span class="o">-</span><span class="n">SIZE_T_ONE</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">]);</span><span class="err">\</span> 
<span class="mi">3681</span>        <span class="n">K</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3682</span>        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">C</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="err">\</span> 
<span class="mi">3683</span>          <span class="n">T</span> <span class="o">=</span> <span class="o">*</span><span class="n">C</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3684</span>        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">)))</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3685</span>          <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3686</span>          <span class="n">X</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3687</span>          <span class="n">X</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">X</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3688</span>          <span class="k">break</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3689</span>        <span class="p">}</span><span class="err">\</span> 
<span class="mi">3690</span>        <span class="k">else</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3691</span>          <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3692</span>          <span class="k">break</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3693</span>        <span class="p">}</span><span class="err">\</span> 
<span class="mi">3694</span>      <span class="p">}</span>\
<span class="c1">// 上面为情况二, 在关键码路径上存在空结点,则插入该结点.</span>
<span class="mi">3695</span>      <span class="k">else</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3696</span>        <span class="n">tchunkptr</span> <span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3697</span>        <span class="k">if</span> <span class="p">(</span><span class="n">RTCHECK</span><span class="p">(</span><span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ok_address</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">F</span><span class="p">)))</span> <span class="p">{</span>\
<span class="mi">3698</span>          <span class="n">T</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3699</span>          <span class="n">X</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">F</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3700</span>          <span class="n">X</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3701</span>          <span class="n">X</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3702</span>          <span class="k">break</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3703</span>        <span class="p">}</span><span class="err">\</span> 
<span class="mi">3704</span>        <span class="k">else</span> <span class="p">{</span><span class="err">\</span> 
<span class="mi">3705</span>          <span class="n">CORRUPTION_ERROR_ACTION</span><span class="p">(</span><span class="n">M</span><span class="p">);</span><span class="err">\</span> 
<span class="mi">3706</span>          <span class="k">break</span><span class="p">;</span><span class="err">\</span> 
<span class="mi">3707</span>        <span class="p">}</span><span class="err">\</span> 
<span class="mi">3708</span>      <span class="p">}</span><span class="err">\</span> 
<span class="mi">3709</span>    <span class="p">}</span><span class="err">\</span> 
<span class="mi">3710</span>  <span class="p">}</span>\

<span class="c1">// 上面为情况三,该大小的结点存在,则插入双向链表.</span>
</pre></div>


<h2 id="_9">总结<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h2>
<p>数据结构总结</p>
<ul>
<li>dlmalloc中按照内存的粒度大小,分为chunk和segment两种数据结构.</li>
<li>dlmalloc中按照内存的大小,有3种内存管理方式,再加上边界标记法,总共四种管理方式:<ul>
<li>边界标记法，并且任意相连两块内存不同为空闲内存.</li>
<li>双向链表管理大小小于256byte的内存.</li>
<li>dlmalloc树与双向链表结合管理大小大于256byte的内存.</li>
<li>单向链表管理segment结构.</li>
</ul>
</li>
<li>dlmalloc通过两个位图分别管理双向链表和dlmalloc树.</li>
</ul>
<div class="codehilite"><pre><span></span><span class="o">+</span><span class="c1">---------------------------segment-------------------------------------+</span>
<span class="o">+</span>  <span class="mi">0</span><span class="n">X10</span>   <span class="o">|</span>  <span class="mi">0</span><span class="n">X12</span>  <span class="o">|</span>  <span class="mi">0</span><span class="n">x109</span> <span class="o">|</span>  <span class="mi">0</span><span class="n">x110</span> <span class="o">|</span>                                  <span class="o">+</span>
<span class="o">+</span> <span class="n">chunk0</span>  <span class="o">|</span> <span class="n">chunk1</span> <span class="o">|</span> <span class="n">chunk2</span> <span class="o">|</span> <span class="n">chunk3</span> <span class="o">|</span>            <span class="n">top</span>                   <span class="o">+</span>
<span class="o">+</span><span class="c1">-----------------------------------------------------------------------+</span>
</pre></div>


<p>上面的数字为chunk结构体中的size.
chunk0和chunk1 都为小内存,大小为0x10, 16byte.而 chunk1 的0x02是表示chunk0表示自己使用.chunk0 归属与箱号为2,由双向链表管理.
chunk2和chunk3 为大内存, 大小为0x108, 264byte. chunk2 大小 | 0x01表示前一个内存块被使用. chunk3 | 0x02 因为自己在被使用. 这两个归属与箱号为0的树管理.
最后 是top块.</p>
<p>setgment由系统通过sbrk分配.
top 从segment而来.如果top超过一个阀值,就会通过sbrk,缩小.如果太小,通过sbrk扩大top.
各个chunk 由 top切分, 或者free时, 或者dv chunk被替换时产生.</p>
<p>算法总结:</p>
<ul>
<li>
<p>小内存分配规则</p>
<ul>
<li>跟据请求大小,优先寻找最匹配的箱子,之后临近箱子.在能不分割内存的情况下尽量不分割内存.</li>
<li>如果dv chunk足够大,则使用dv chunk.</li>
<li>如果前两个不满足,则在smallbin中寻找最接近请求大小的空闲块箱号.</li>
<li>如果top 足够大,使用top.</li>
<li>如果请求内存实在太大,则使用系统分配.</li>
</ul>
</li>
<li>
<p>大内存分配规则</p>
<ul>
<li>如果treebin中找到最合适的最小内存,如果它比dv chunk更合适,就使用它.</li>
<li>如果dv chunk比其他所有合适,则使用dv chunk.</li>
<li>如果top 足够大,则使用top.</li>
<li>如果请求大小 &gt;= mmap的阀值,则使用mmap.</li>
<li>直接从系统分配内存.</li>
</ul>
</li>
<li>
<p>内存释放规则</p>
<ul>
<li>如果在虚拟内存上的当前释放内存的前/后一个内存为空闲,则合并.</li>
<li>如果前/后一个内存为dv chunk, 则合并到dv chunk</li>
<li>如果后一个内存为top, 则合并到top</li>
<li>如果前/后一个内存为普通内存块,则删除后,查找并插入符合大小的箱子中.</li>
</ul>
</li>
<li>
<p>smallbin 和 treebin的规则.</p>
<ul>
<li>smallbin 为32bit数,没一个bit对应一个箱子的状态.1 为有空闲内存, 0 为无. 32个箱子的大小为以8 为基数, 以8 为增率, 长度为32的等差数列</li>
<li>treebin的状态与smallbin一致. treebin的各个箱子的大小见上文.</li>
</ul>
</li>
<li>
<p>treebin中的树的搜索算法</p>
<ul>
<li>该树表示一段内存范围.所以没一棵子树用二分法表示对应的区间范围.</li>
<li>左子树上的任意chunk大小 都小于其右子树的任意chunk的大小,</li>
<li>参考 <code>tmalloc_large</code>,<code>insert_large_chunk</code> 和<code>unlink_large_chunk</code>的解析.</li>
</ul>
</li>
</ul>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../tcmalloc2.1浅析/" title="tcmalloc2.1 浅析" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                tcmalloc2.1 浅析
              </span>
            </div>
          </a>
        
        
          <a href="../binder/" title="binder" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                binder
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2018 Werther Zhang
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../assets/fonts/font-awesome.css">
    
      <a href="http://wertherzhang.coding.me/" class="md-footer-social__link fa fa-coding"></a>
    
      <a href="https://pengzhang.netlify.com/" class="md-footer-social__link fa fa-netlify"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.245445c6.js"></script>
      
        
        
          
          <script src="../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
          
            
              
              
            
          
          
            <script src="../assets/javascripts/lunr/lunr.multi.js"></script>
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>