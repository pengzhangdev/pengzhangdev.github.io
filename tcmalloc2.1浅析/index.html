



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="The documents of Werther Zhang">
      
      
        <link rel="canonical" href="https://wertherzhang.com/tcmalloc2.1浅析/">
      
      
        <meta name="author" content="Werther Zhang">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="en, jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>tcmalloc2.1 浅析 - 万卷茅屋</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#2196f3">
      
    
    
      <script src="../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700|Ubuntu+Mono&display=fallback">
        <style>body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Ubuntu Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="blue" data-md-color-accent="light-blue">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#tcmalloc21" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://wertherzhang.com" title="万卷茅屋" class="md-header-nav__button md-logo">
          
            <i class="md-icon">whatshot</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              万卷茅屋
            </span>
            <span class="md-header-nav__topic">
              
                tcmalloc2.1 浅析
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href=".." title="万卷茅屋" class="md-tabs__link">
        万卷茅屋
      </a>
    
  </li>

      
        
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../zram/" title="Android" class="md-tabs__link md-tabs__link--active">
          Android
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../跟我读源码--换个角度看init/" title="跟我读源码" class="md-tabs__link">
          跟我读源码
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../slackbot/" title="Python" class="md-tabs__link">
          Python
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../C-CPP-N诫/" title="搬运工" class="md-tabs__link">
          搬运工
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://wertherzhang.com" title="万卷茅屋" class="md-nav__button md-logo">
      
        <i class="md-icon">whatshot</i>
      
    </a>
    万卷茅屋
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="万卷茅屋" class="md-nav__link">
      万卷茅屋
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../about/" title="关于" class="md-nav__link">
      关于
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Android
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Android
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../zram/" title="zram" class="md-nav__link">
      zram
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../android8-partiton-table/" title="Android8分区表分析" class="md-nav__link">
      Android8分区表分析
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Android-AB-system-update/" title="AB系统升级" class="md-nav__link">
      AB系统升级
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../recovery5.0详解/" title="Recovery5二次开发详解" class="md-nav__link">
      Recovery5二次开发详解
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Android-memory-debug/" title="Android内存调试总结" class="md-nav__link">
      Android内存调试总结
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../SEAndroid规则介绍/" title="Android SELinux 规则介绍" class="md-nav__link">
      Android SELinux 规则介绍
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        tcmalloc2.1 浅析
      </label>
    
    <a href="./" title="tcmalloc2.1 浅析" class="md-nav__link md-nav__link--active">
      tcmalloc2.1 浅析
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" title="简介" class="md-nav__link">
    简介
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="原理简析" class="md-nav__link">
    原理简析
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#overview" title="overview" class="md-nav__link">
    overview
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" title="小对象内存分配" class="md-nav__link">
    小对象内存分配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="大对象内存分配" class="md-nav__link">
    大对象内存分配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="算法" class="md-nav__link">
    算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#review" title="代码review" class="md-nav__link">
    代码review
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" title="总结" class="md-nav__link">
    总结
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tcmalloc" title="tcmalloc优势" class="md-nav__link">
    tcmalloc优势
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tcmalloc_1" title="tcmalloc劣势" class="md-nav__link">
    tcmalloc劣势
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mem" title="对mem测试的数据总结" class="md-nav__link">
    对mem测试的数据总结
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../dlmalloc浅析/" title="dlmalloc 浅析" class="md-nav__link">
      dlmalloc 浅析
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../binder/" title="binder" class="md-nav__link">
      binder
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../jemalloc剖析/" title="jemalloc" class="md-nav__link">
      jemalloc
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      跟我读源码
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        跟我读源码
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../跟我读源码--换个角度看init/" title="换个角度看init" class="md-nav__link">
      换个角度看init
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Python
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Python
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../slackbot/" title="slackbot详细说明" class="md-nav__link">
      slackbot详细说明
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      搬运工
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        搬运工
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../C-CPP-N诫/" title="C and CPP N 诫" class="md-nav__link">
      C and CPP N 诫
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" title="简介" class="md-nav__link">
    简介
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" title="原理简析" class="md-nav__link">
    原理简析
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#overview" title="overview" class="md-nav__link">
    overview
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" title="小对象内存分配" class="md-nav__link">
    小对象内存分配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" title="大对象内存分配" class="md-nav__link">
    大对象内存分配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" title="算法" class="md-nav__link">
    算法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#review" title="代码review" class="md-nav__link">
    代码review
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" title="总结" class="md-nav__link">
    总结
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tcmalloc" title="tcmalloc优势" class="md-nav__link">
    tcmalloc优势
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tcmalloc_1" title="tcmalloc劣势" class="md-nav__link">
    tcmalloc劣势
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mem" title="对mem测试的数据总结" class="md-nav__link">
    对mem测试的数据总结
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <ul>
<li>version 1.0 done by wertherzhang @2014-05-12 write done with emacs org</li>
<li>version 1.1 done by wertherzhang @2017-03-16 moved to leanote</li>
</ul>
<h1 id="tcmalloc21">tcmalloc2.1 浅析<a class="headerlink" href="#tcmalloc21" title="Permanent link">&para;</a></h1>
<p>来源: https://pengzhangdev.github.io/tcmalloc2.1%E6%B5%85%E6%9E%90/</p>
<h2 id="_1">简介<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>tcmalloc(thread cached malloc) 是由google为并发程序而开发的内存分配管理器.tcmalloc致力于减少多线程内存请求时对锁的竞争, 在对小内存的申请时,可以在无需锁的情况下高效获取内存;而在获取大内存时,使用高校的spinlocks.正因为tcmalloc是在线程局部空间(TLS)预先存储部分空闲内存用于分配, 在程序刚启动时,其所占用的内存会比dlmalloc或其他的内存管理器更大,但其增长速幅度比其他管理器小,所以,在后期,实际占用内存空间会相接近.</p>
<h2 id="_2">原理简析<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<h3 id="overview">overview<a class="headerlink" href="#overview" title="Permanent link">&para;</a></h3>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/tcmalloc2.1浅析-0.png" /></p>
<p>tcmalloc为每一个线程分配一个线程本地缓存(Thread Cache, 以下简称TC)．所有小对象(&lt;256K)都会优先从ThreadCache分配．而当ThreadCache没有足够空闲内存时，就会从CentralCache(以下简称CC)申请内存.而当Thread Cache内存富裕时,会将内存返回给Central Cache. Central Cache是以进程为单位存在,ThreadCache是以线程为单位存在.对于大内存(&gt;256K), 直接从Page Heap(以下简称PH)按页对齐(4K)申请.通常情况下,一连串的页面(4k)可以多个小内存序列,每个序列元素等大小.TC, CC, PH 的关系是, TC 向CC申请内存并GC给CC. CC 向PH 申请内存并GC给PH.在TC中的数据单位时字节,按大小为单位分类,每个类中时链表.在PH中的数据单位时Page(4K),按PageNum分类,每个分类内部用链表管理,第PageNum类的链表结点为PageNum个Page.在CC中存在最多的数据结构,它连接着TC和PH.其存放了来自CC的slot结构,和来自PH的PH的span结构.数据的移动. 所有的数据从TC&lt;-&gt;CC&lt;-&gt;PH都是批量(batch)移动.从TC申请或释放的内存都会优先从CC的slots数组处理.slots存放的就是最近从TC释放的内存,用于快速的TC内存申请.如果slots条件不满足,就会操作CC中的spans对象.所有移动的数据的大小和TC中的最大大小都是在动态调整的.</p>
<h3 id="_3">小对象内存分配<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/tcmalloc2.1浅析-1.png" /></p>
<p>上图为小内存管理时的sizemap分类的示意图.小内存的管理都处于ThreadCache中.所有对于256k以下的内存申请都是从TC中获取.个人把小内存分配,理解为3级内存请求.进程向TC请求内存, TC向CC请求内存,CC向PH请求内存.</p>
<ul>
<li>
<p>进程向TC请求和释放内存内存</p>
<ul>
<li>TC内存管理
  首先, 在进程空间中,对于每一个线程,存在与其对应的TC, 所有的TC被用链表串联,不属于任何一个线程独有.通过这种,每一个TC都可以看到任何一个TC.如上图,在TC中对内存进行了分类管理,每一个请求的内存大小都会向上取整到对应分类,然后直接从对应的链表中取出一项.</li>
<li>
<p>进程向TC申请内存</p>
<ul>
<li>将请求内存向上对其到size class.</li>
<li>从对应size class中查找空闲内存, 如果存在,直接返回.</li>
<li>如果size class中无空闲内存,则触发向CC请求内存的机制.</li>
</ul>
</li>
<li>
<p>进程向TC释放内存</p>
<ul>
<li>从释放内存的地址,查找对应的pageID.</li>
<li>如果page ID 属于TC, 并且TC的Heap存在,则释放到TC中</li>
<li>如果PageID属于TC,而TC的Heap不存在(跨线程内存申请和释放, 申请线程被销毁的情况下),则释放到CC中,参考TC向CC释放内存</li>
<li>如果pageID属于PH中(大内存), 则直接释放到PH中.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TC向CC请求和释放内存</p>
<ul>
<li>
<p>CC的内存管理.
    在CC中同样维护了与TC中对应的分类箱子.每个类别中是一个CentralFreeList类. 该类中维护了一个slots双向链表,用于快速分配内存给CC并接收释放的内存, 其内存粒度与TC中相同.同样,该类中也维护了两个span双向链表,empty(不包含空闲块)和nonempty(包含空闲块).span会在这两个链表中移动.Span是个什么东西呢?它是PH内存管理的一个粒度,其表示的内存大小为page(4K)的倍数.同时,它包含了更小的粒度单位objects. 所以,也可以认为它是CC和PH之间移动的内存单元.所以,Span和slots的关系是,spans可以拆分成slots</p>
<p>这里,我们认为span属于PH的,所以,跟span的相关操作我们在PH讲解.</p>
<p>``` <br />
    class CentralFreeList {
       // ...</p>
<div class="codehilite"><pre><span></span><span class="nv">private</span>:
   <span class="o">//</span>...

  <span class="o">//</span> <span class="nv">We</span> <span class="nv">keep</span> <span class="nv">linked</span> <span class="nv">lists</span> <span class="nv">of</span> <span class="nv">empty</span> <span class="nv">and</span> <span class="nv">non</span><span class="o">-</span><span class="nv">empty</span> <span class="nv">spans</span>.
  <span class="nv">size_t</span>   <span class="nv">size_class_</span><span class="c1">;     // My size class</span>
  <span class="nv">Span</span>     <span class="nv">empty_</span><span class="c1">;          // Dummy header for list of empty spans</span>
  <span class="nv">Span</span>     <span class="nv">nonempty_</span><span class="c1">;       // Dummy header for list of non-empty spans</span>
  <span class="nv">size_t</span>   <span class="nv">num_spans_</span><span class="c1">;      // Number of spans in empty_ plus nonempty_</span>
  <span class="nv">size_t</span>   <span class="nv">counter_</span><span class="c1">;        // Number of free objects in cache entry</span>

  <span class="o">//</span> <span class="nv">Here</span> <span class="nv">we</span> <span class="nv">reserve</span> <span class="nv">space</span> <span class="k">for</span> <span class="nv">TCEntry</span> <span class="nv">cache</span> <span class="nv">slots</span>.  <span class="nv">Space</span> <span class="nv">is</span> <span class="nv">preallocated</span>
  <span class="o">//</span> <span class="k">for</span> <span class="nv">the</span> <span class="nv">largest</span> <span class="nv">possible</span> <span class="nv">number</span> <span class="nv">of</span> <span class="nv">entries</span> <span class="nv">than</span> <span class="nv">any</span> <span class="nv">one</span> <span class="nv">size</span> <span class="nv">class</span> <span class="nv">may</span>
  <span class="o">//</span> <span class="nv">accumulate</span>.  <span class="nv">Not</span> <span class="nv">all</span> <span class="nv">size</span> <span class="nv">classes</span> <span class="nv">are</span> <span class="nv">allowed</span> <span class="nv">to</span> <span class="nv">accumulate</span>
  <span class="o">//</span> <span class="nv">kMaxNumTransferEntries</span>, <span class="nv">so</span> <span class="nv">there</span> <span class="nv">is</span> <span class="nv">some</span> <span class="nv">wasted</span> <span class="nv">space</span> <span class="k">for</span> <span class="nv">those</span> <span class="nv">size</span>
  <span class="o">//</span> <span class="nv">classes</span>.
  <span class="nv">TCEntry</span> <span class="nv">tc_slots_</span>[<span class="nv">kMaxNumTransferEntries</span>]<span class="c1">;</span>

  <span class="o">//</span> ...
}<span class="c1">;</span>

<span class="o">//</span> <span class="nv">Information</span> <span class="nv">kept</span> <span class="k">for</span> <span class="nv">a</span> <span class="nv">span</span> <span class="ss">(</span><span class="nv">a</span> <span class="nv">contiguous</span> <span class="nv">run</span> <span class="nv">of</span> <span class="nv">pages</span><span class="ss">)</span>.
<span class="nv">struct</span> <span class="nv">Span</span> {
  <span class="nv">PageID</span>        <span class="nv">start</span><span class="c1">;          // Starting page number</span>
  <span class="nv">Length</span>        <span class="nv">length</span><span class="c1">;         // Number of pages in span</span>
  <span class="nv">Span</span><span class="o">*</span>         <span class="k">next</span><span class="c1">;           // Used when in link list</span>
  <span class="nv">Span</span><span class="o">*</span>         <span class="nv">prev</span><span class="c1">;           // Used when in link list</span>
  <span class="nv">void</span><span class="o">*</span>         <span class="nv">objects</span><span class="c1">;        // Linked list of free objects</span>
  <span class="nv">unsigned</span> <span class="nv">int</span>  <span class="nv">refcount</span> : <span class="mi">16</span><span class="c1">;  // Number of non-free objects // 当refcount为0, 则释放给PageHeap.</span>
  <span class="nv">unsigned</span> <span class="nv">int</span>  <span class="nv">sizeclass</span> : <span class="mi">8</span><span class="c1">;  // Size-class for small objects (or 0)  // 这个是TC的 SizeClass 分类.因为每个分类对应一个CentralFreeList,每个List对应1个slots和2个spans. 所以,spans中的objects都统一属于某个SizeClass, 这里需要维护这个数据对object的.</span>
  <span class="nv">unsigned</span> <span class="nv">int</span>  <span class="nv">location</span> : <span class="mi">2</span><span class="c1">;   // Is the span on a freelist, and if so, which?  // 在empty/nonempty list?</span>
  <span class="nv">unsigned</span> <span class="nv">int</span>  <span class="nv">sample</span> : <span class="mi">1</span><span class="c1">;     // Sampled object?</span>

#<span class="nv">undef</span> <span class="nv">SPAN_HISTORY</span>
#<span class="nv">ifdef</span> <span class="nv">SPAN_HISTORY</span>
  <span class="o">//</span> <span class="k">For</span> <span class="nv">debugging</span>, <span class="nv">we</span> <span class="nv">can</span> <span class="nv">keep</span> <span class="nv">a</span> <span class="nv">log</span> <span class="nv">events</span> <span class="nv">per</span> <span class="nv">span</span>
  <span class="nv">int</span> <span class="nv">nexthistory</span><span class="c1">;</span>
  <span class="nv">char</span> <span class="nv">history</span>[<span class="mi">64</span>]<span class="c1">;</span>
  <span class="nv">int</span> <span class="nv">value</span>[<span class="mi">64</span>]<span class="c1">;</span>
#<span class="k">endif</span>

  <span class="o">//</span> <span class="nv">What</span> <span class="nv">freelist</span> <span class="nv">the</span> <span class="nv">span</span> <span class="nv">is</span> <span class="nv">on</span>: <span class="nv">IN_USE</span> <span class="k">if</span> <span class="nv">on</span> <span class="nv">none</span>, <span class="nv">or</span> <span class="nv">normal</span> <span class="nv">or</span> <span class="nv">returned</span>
  <span class="nv">enum</span> { <span class="nv">IN_USE</span>, <span class="nv">ON_NORMAL_FREELIST</span>, <span class="nv">ON_RETURNED_FREELIST</span> }<span class="c1">;</span>
}<span class="c1">;</span>
</pre></div>


<p>```</p>
</li>
<li>
<p>TC向CC请求内存
    TC只有在其对应的分类中,不存在空闲块时,才会向CC的对应分类申请batch_size的空闲块.</p>
<ul>
<li>根据当前请求的内存,找到对应的分类,和该分类下的默认CC请求的对象个数(<code>batch_size</code>). 在该分类free list的最大长度和<code>batch_size</code>中取最小值为需要申请的对象个数(<code>num_to_move</code>).</li>
<li>基于慢启动算法,缓慢增加当前分类的free list容量.</li>
<li>从CC的对应分类中的slots对像,获取相应数量的objects.</li>
<li>如果slots不满足,则从spans对象中获取相应的objects.</li>
<li>如果spans不满足(nonempty为NULL),则触发CC向PH请求内存.</li>
</ul>
<p>```
    inline void* ThreadCache::Allocate(size_t size, size_t cl) {
      // size 已经被向上对齐, cl为分类的箱号
      ASSERT(size &lt;= kMaxSize);
      // kMaxSzie == 256 * 1024
      ASSERT(size == Static::sizemap()-&gt;ByteSizeForClass(cl));
      // sizemap() 为分类的数组.每个成员为链表.
      // ByteSizeForClass是取出对应箱号内的理论内存大小.</p>
<div class="codehilite"><pre><span></span>  <span class="o">//</span> 以上<span class="nv">assert</span> 检查,理应在调用该函数之前保证.

  <span class="nv">FreeList</span><span class="o">*</span> <span class="nv">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">list_</span>[<span class="nv">cl</span>]<span class="c1">;</span>
  <span class="k">if</span> <span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">empty</span><span class="ss">())</span> {
    <span class="k">return</span> <span class="nv">FetchFromCentralCache</span><span class="ss">(</span><span class="nv">cl</span>, <span class="nv">size</span><span class="ss">)</span><span class="c1">;</span>
  }
  <span class="nv">size_</span> <span class="o">-=</span> <span class="nv">size</span><span class="c1">;</span>
  <span class="k">return</span> <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">Pop</span><span class="ss">()</span><span class="c1">;</span>
}
</pre></div>


<p>```</p>
<p>我们重点描述下,TC向CC申请内存的过程.首先,我们需要知道,CC也按照TC的内存分类方式,存在各个分类的箱子.所以,实际上是向CC中的对应分类获取一连串的空闲内存.首先,我们得确定,移动的内存数量,也就是对应分类的内存块个数.默认情况下, 有一个规则确定每个分类对应的该移动的内存数量.以64K为基准,除以对应分类的内存大小,算出来的为移动的内存数量.但是,对于一些极小内存,这个值将很大,所以,我们限制最大为32768个,同理,对于极大内存,这个值&lt;=1,会导致这个分类的内存请求每次都向CC请求,所以,我们这只最小为2,保证最多每2次向CC请求一次内存.下面为,默认的分类和对应的移动数量.</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>idx</th>
<th><code>class_size</code></th>
<th><code>num_to_move_objs</code></th>
<th><code>num_to_move_pages</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8</td>
<td>8192</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>4096</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>32</td>
<td>2048</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>48</td>
<td>1365</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>64</td>
<td>1024</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>80</td>
<td>819</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>96</td>
<td>682</td>
<td>2</td>
</tr>
<tr>
<td>8</td>
<td>112</td>
<td>585</td>
<td>2</td>
</tr>
<tr>
<td>9</td>
<td>128</td>
<td>512</td>
<td>2</td>
</tr>
<tr>
<td>10</td>
<td>144</td>
<td>455</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>160</td>
<td>409</td>
<td>2</td>
</tr>
<tr>
<td>12</td>
<td>176</td>
<td>372</td>
<td>2</td>
</tr>
<tr>
<td>13</td>
<td>192</td>
<td>341</td>
<td>2</td>
</tr>
<tr>
<td>14</td>
<td>208</td>
<td>315</td>
<td>2</td>
</tr>
<tr>
<td>15</td>
<td>224</td>
<td>292</td>
<td>2</td>
</tr>
<tr>
<td>16</td>
<td>240</td>
<td>273</td>
<td>2</td>
</tr>
<tr>
<td>17</td>
<td>256</td>
<td>256</td>
<td>2</td>
</tr>
<tr>
<td>18</td>
<td>288</td>
<td>227</td>
<td>2</td>
</tr>
<tr>
<td>19</td>
<td>320</td>
<td>204</td>
<td>2</td>
</tr>
<tr>
<td>20</td>
<td>352</td>
<td>186</td>
<td>2</td>
</tr>
<tr>
<td>21</td>
<td>384</td>
<td>170</td>
<td>2</td>
</tr>
<tr>
<td>22</td>
<td>416</td>
<td>157</td>
<td>2</td>
</tr>
<tr>
<td>23</td>
<td>448</td>
<td>146</td>
<td>2</td>
</tr>
<tr>
<td>24</td>
<td>480</td>
<td>136</td>
<td>2</td>
</tr>
<tr>
<td>25</td>
<td>512</td>
<td>128</td>
<td>2</td>
</tr>
<tr>
<td>26</td>
<td>576</td>
<td>113</td>
<td>2</td>
</tr>
<tr>
<td>27</td>
<td>640</td>
<td>102</td>
<td>2</td>
</tr>
<tr>
<td>28</td>
<td>704</td>
<td>93</td>
<td>2</td>
</tr>
<tr>
<td>29</td>
<td>768</td>
<td>85</td>
<td>2</td>
</tr>
<tr>
<td>30</td>
<td>832</td>
<td>78</td>
<td>2</td>
</tr>
<tr>
<td>31</td>
<td>896</td>
<td>73</td>
<td>2</td>
</tr>
<tr>
<td>32</td>
<td>960</td>
<td>68</td>
<td>2</td>
</tr>
<tr>
<td>33</td>
<td>1024</td>
<td>64</td>
<td>2</td>
</tr>
<tr>
<td>34</td>
<td>1152</td>
<td>56</td>
<td>2</td>
</tr>
<tr>
<td>35</td>
<td>1280</td>
<td>51</td>
<td>2</td>
</tr>
<tr>
<td>36</td>
<td>1408</td>
<td>46</td>
<td>2</td>
</tr>
<tr>
<td>37</td>
<td>1536</td>
<td>42</td>
<td>2</td>
</tr>
<tr>
<td>38</td>
<td>1792</td>
<td>36</td>
<td>2</td>
</tr>
<tr>
<td>39</td>
<td>2048</td>
<td>32</td>
<td>2</td>
</tr>
<tr>
<td>40</td>
<td>2304</td>
<td>28</td>
<td>2</td>
</tr>
<tr>
<td>41</td>
<td>2560</td>
<td>25</td>
<td>2</td>
</tr>
<tr>
<td>42</td>
<td>2816</td>
<td>23</td>
<td>3</td>
</tr>
<tr>
<td>43</td>
<td>3072</td>
<td>21</td>
<td>2</td>
</tr>
<tr>
<td>44</td>
<td>3328</td>
<td>19</td>
<td>3</td>
</tr>
<tr>
<td>45</td>
<td>4096</td>
<td>16</td>
<td>2</td>
</tr>
<tr>
<td>46</td>
<td>4608</td>
<td>14</td>
<td>3</td>
</tr>
<tr>
<td>47</td>
<td>5120</td>
<td>12</td>
<td>2</td>
</tr>
<tr>
<td>48</td>
<td>6144</td>
<td>10</td>
<td>3</td>
</tr>
<tr>
<td>49</td>
<td>6656</td>
<td>9</td>
<td>5</td>
</tr>
<tr>
<td>50</td>
<td>8192</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>51</td>
<td>9216</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>52</td>
<td>10240</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>53</td>
<td>12288</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>54</td>
<td>13312</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>55</td>
<td>16384</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>56</td>
<td>20480</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>57</td>
<td>24576</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>58</td>
<td>26624</td>
<td>2</td>
<td>7</td>
</tr>
<tr>
<td>59</td>
<td>32768</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>60</td>
<td>40960</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>61</td>
<td>49152</td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td>62</td>
<td>57344</td>
<td>2</td>
<td>7</td>
</tr>
<tr>
<td>63</td>
<td>65536</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td>64</td>
<td>73728</td>
<td>2</td>
<td>9</td>
</tr>
<tr>
<td>65</td>
<td>81920</td>
<td>2</td>
<td>10</td>
</tr>
<tr>
<td>66</td>
<td>90112</td>
<td>2</td>
<td>11</td>
</tr>
<tr>
<td>67</td>
<td>98304</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>68</td>
<td>106496</td>
<td>2</td>
<td>13</td>
</tr>
<tr>
<td>69</td>
<td>114688</td>
<td>2</td>
<td>14</td>
</tr>
<tr>
<td>70</td>
<td>122880</td>
<td>2</td>
<td>15</td>
</tr>
<tr>
<td>71</td>
<td>131072</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>72</td>
<td>139264</td>
<td>2</td>
<td>17</td>
</tr>
<tr>
<td>73</td>
<td>147456</td>
<td>2</td>
<td>18</td>
</tr>
<tr>
<td>74</td>
<td>155648</td>
<td>2</td>
<td>19</td>
</tr>
<tr>
<td>75</td>
<td>163840</td>
<td>2</td>
<td>20</td>
</tr>
<tr>
<td>76</td>
<td>172032</td>
<td>2</td>
<td>21</td>
</tr>
<tr>
<td>77</td>
<td>180224</td>
<td>2</td>
<td>22</td>
</tr>
<tr>
<td>78</td>
<td>188416</td>
<td>2</td>
<td>23</td>
</tr>
<tr>
<td>79</td>
<td>196608</td>
<td>2</td>
<td>24</td>
</tr>
<tr>
<td>80</td>
<td>204800</td>
<td>2</td>
<td>25</td>
</tr>
<tr>
<td>81</td>
<td>212992</td>
<td>2</td>
<td>26</td>
</tr>
<tr>
<td>82</td>
<td>221184</td>
<td>2</td>
<td>27</td>
</tr>
<tr>
<td>83</td>
<td>229376</td>
<td>2</td>
<td>28</td>
</tr>
<tr>
<td>84</td>
<td>237568</td>
<td>2</td>
<td>29</td>
</tr>
<tr>
<td>85</td>
<td>245760</td>
<td>2</td>
<td>30</td>
</tr>
<tr>
<td>86</td>
<td>253952</td>
<td>2</td>
<td>31</td>
</tr>
<tr>
<td>87</td>
<td>262144</td>
<td>2</td>
<td>32</td>
</tr>
</tbody>
</table>
<div class="codehilite"><pre><span></span>    以上只是默认值,这个值是会随着内存申请次数的增加而调整, <span class="nv">google</span>给这个算法取名为慢启动<span class="ss">(</span><span class="nv">slow</span><span class="o">-</span><span class="nv">start</span><span class="ss">)</span>算法. 我们来看下.首先, <span class="nv">list</span>有个最大值,我们能移动的大小为<span class="nv">list</span>最大长度和默认中的最小值. 为了保证,在大量申请时的效率, 在<span class="nv">max</span> <span class="nv">length</span> <span class="o">&lt;</span> 默认值时,我们慢慢增长<span class="nv">max</span> <span class="nv">length</span>, 防止浪费空间,又能有效地逐渐提高效率. 在<span class="nv">max</span> <span class="nv">length</span> <span class="o">&gt;</span> 默认值时,要么时大量请求,要么是由于请求的内存很大,导致默认值小,所以,这个时候,可以每次增加默认值大小.但最大移动数依然时默认的移动数.

    ```
        <span class="o">//</span> <span class="nv">slow</span><span class="o">-</span><span class="nv">start</span>
                <span class="ss">(</span><span class="nv">setq</span> <span class="nv">batch_size</span> <span class="nv">num_to_move</span><span class="ss">)</span>
                <span class="ss">(</span><span class="nv">setq</span> <span class="nv">list_length</span> <span class="nv">get_list_length_max_length</span><span class="ss">)</span>
                <span class="ss">(</span><span class="nv">fetch</span><span class="o">-</span><span class="nv">mem</span> <span class="ss">(</span><span class="nv">min</span> <span class="nv">batch_size</span> <span class="nv">list_length</span><span class="ss">))</span>
                <span class="ss">(</span><span class="nv">set</span><span class="o">-</span><span class="nv">list</span><span class="o">-</span><span class="nv">max</span><span class="o">-</span><span class="nv">length</span> 
                        <span class="ss">(</span><span class="k">if</span> <span class="ss">(</span><span class="o">&lt;</span> <span class="nv">list_length</span> <span class="nv">batch_size</span><span class="ss">)</span>
                               <span class="ss">(</span><span class="o">+</span> <span class="nv">list_length</span> <span class="mi">1</span><span class="ss">)</span>
                              <span class="ss">(</span><span class="o">+</span> <span class="nv">list_length</span> <span class="nv">batch_size</span><span class="ss">)))</span>

        <span class="o">//</span> <span class="nv">Remove</span> <span class="nv">some</span> <span class="nv">objects</span> <span class="nv">of</span> <span class="nv">class</span> <span class="s2">&quot;</span><span class="s">cl</span><span class="s2">&quot;</span> <span class="nv">from</span> <span class="nv">central</span> <span class="nv">cache</span> <span class="nv">and</span> <span class="nv">add</span> <span class="nv">to</span> <span class="nv">thread</span> <span class="nv">heap</span>.
        <span class="o">//</span> <span class="nv">On</span> <span class="nv">success</span>, <span class="k">return</span> <span class="nv">the</span> <span class="nv">first</span> <span class="nv">object</span> <span class="k">for</span> <span class="nv">immediate</span> <span class="nv">use</span><span class="c1">; otherwise return NULL.</span>
        <span class="nv">void</span><span class="o">*</span> <span class="nv">ThreadCache</span>::<span class="nv">FetchFromCentralCache</span><span class="ss">(</span><span class="nv">size_t</span> <span class="nv">cl</span>, <span class="nv">size_t</span> <span class="nv">byte_size</span><span class="ss">)</span> {
          <span class="nv">FreeList</span><span class="o">*</span> <span class="nv">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">list_</span>[<span class="nv">cl</span>]<span class="c1">;</span>
          <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">empty</span><span class="ss">())</span><span class="c1">;</span>
          <span class="o">//</span> <span class="nv">batch_size</span> 为默认的移动数量
          <span class="nv">const</span> <span class="nv">int</span> <span class="nv">batch_size</span> <span class="o">=</span> <span class="nv">Static</span>::<span class="nv">sizemap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">num_objects_to_move</span><span class="ss">(</span><span class="nv">cl</span><span class="ss">)</span><span class="c1">;</span>

          <span class="o">//</span> 考虑到<span class="nv">list</span>的大小,我们取<span class="nv">list</span>最大长度和<span class="nv">batch_size</span>中的最小值.
          <span class="nv">const</span> <span class="nv">int</span> <span class="nv">num_to_move</span> <span class="o">=</span> <span class="nv">min</span><span class="o">&lt;</span><span class="nv">int</span><span class="o">&gt;</span><span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span>, <span class="nv">batch_size</span><span class="ss">)</span><span class="c1">;</span>
          <span class="nv">void</span> <span class="o">*</span><span class="nv">start</span>, <span class="o">*</span><span class="k">end</span><span class="c1">;</span>
          <span class="o">//</span> 从<span class="nv">CC</span>获取内存, 只是简单的链表删除操作
          <span class="nv">int</span> <span class="nv">fetch_count</span> <span class="o">=</span> <span class="nv">Static</span>::<span class="nv">central_cache</span><span class="ss">()</span>[<span class="nv">cl</span>].<span class="nv">RemoveRange</span><span class="ss">(</span>
              <span class="o">&amp;</span><span class="nv">start</span>, <span class="o">&amp;</span><span class="k">end</span>, <span class="nv">num_to_move</span><span class="ss">)</span><span class="c1">;</span>

          <span class="nv">ASSERT</span><span class="ss">((</span><span class="nv">start</span> <span class="o">==</span> <span class="nv">NULL</span><span class="ss">)</span> <span class="o">==</span> <span class="ss">(</span><span class="nv">fetch_count</span> <span class="o">==</span> <span class="mi">0</span><span class="ss">))</span><span class="c1">;</span>
          <span class="k">if</span> <span class="ss">(</span><span class="o">--</span><span class="nv">fetch_count</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="ss">)</span> {
            <span class="o">//</span> <span class="nv">size_</span>为获取到的内存大小
            <span class="nv">size_</span> <span class="o">+=</span> <span class="nv">byte_size</span> <span class="o">*</span> <span class="nv">fetch_count</span><span class="c1">;</span>
            <span class="o">//</span> 添加到单向链表中.链表插入操作.
            <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">PushRange</span><span class="ss">(</span><span class="nv">fetch_count</span>, <span class="nv">SLL_Next</span><span class="ss">(</span><span class="nv">start</span><span class="ss">)</span>, <span class="k">end</span><span class="ss">)</span><span class="c1">;</span>
          }

          <span class="o">//</span> 如果<span class="nv">list</span>的最大长度 <span class="o">&lt;</span> 默认移动长度, 则<span class="nv">list</span>最大长度<span class="o">+</span><span class="mi">1</span>, 慢慢靠近默认移动长度.
          <span class="k">if</span> <span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">&lt;</span> <span class="nv">batch_size</span><span class="ss">)</span> {
            <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">set_max_length</span><span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">+</span> <span class="mi">1</span><span class="ss">)</span><span class="c1">;</span>
          } <span class="k">else</span> {
            <span class="o">//</span> 否则,我们直接增长<span class="nv">batch_size</span> 长度, 当然不允许无限增长.
            <span class="nv">int</span> <span class="nv">new_length</span> <span class="o">=</span> <span class="nv">min</span><span class="o">&lt;</span><span class="nv">int</span><span class="o">&gt;</span><span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">+</span> <span class="nv">batch_size</span>,
                                      <span class="nv">kMaxDynamicFreeListLength</span><span class="ss">)</span><span class="c1">;</span>
            <span class="o">//</span> 必须保证<span class="nv">max_length</span> 时<span class="nv">batch_size</span>的整数倍,这样才能做到在<span class="nv">N</span>次<span class="nv">batch_size</span>的移动正好释放完<span class="nv">list</span>, 而不需要分割.
            <span class="nv">new_length</span> <span class="o">-=</span> <span class="nv">new_length</span> <span class="o">%</span> <span class="nv">batch_size</span><span class="c1">;</span>
            <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">new_length</span> <span class="o">%</span> <span class="nv">batch_size</span> <span class="o">==</span> <span class="mi">0</span><span class="ss">)</span><span class="c1">;</span>
            <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">set_max_length</span><span class="ss">(</span><span class="nv">new_length</span><span class="ss">)</span><span class="c1">;</span>
          }
          <span class="k">return</span> <span class="nv">start</span><span class="c1">;</span>
        }
    ```

    这里实际从<span class="nv">CC</span>获取空闲空间的函数是<span class="nv">RemoveRange</span>函数.首先常试直接从<span class="nv">slots</span>中获取,如果<span class="nv">slots</span>不够,则再从<span class="nv">spans</span>获取.

    ```
        <span class="nv">int</span> <span class="nv">CentralFreeList</span>::<span class="nv">RemoveRange</span><span class="ss">(</span><span class="nv">void</span> <span class="o">**</span><span class="nv">start</span>, <span class="nv">void</span> <span class="o">**</span><span class="k">end</span>, <span class="nv">int</span> <span class="nv">N</span><span class="ss">)</span> {
          <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span><span class="c1">;</span>
          <span class="nv">lock_</span>.<span class="nv">Lock</span><span class="ss">()</span><span class="c1">;</span>
          <span class="k">if</span> <span class="ss">(</span><span class="nv">N</span> <span class="o">==</span> <span class="nv">Static</span>::<span class="nv">sizemap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">num_objects_to_move</span><span class="ss">(</span><span class="nv">size_class_</span><span class="ss">)</span> <span class="o">&amp;&amp;</span>
              <span class="nv">used_slots_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span> {
            <span class="nv">int</span> <span class="nv">slot</span> <span class="o">=</span> <span class="o">--</span><span class="nv">used_slots_</span><span class="c1">;</span>
            <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">slot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="ss">)</span><span class="c1">;</span>
            <span class="nv">TCEntry</span> <span class="o">*</span><span class="nv">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">tc_slots_</span>[<span class="nv">slot</span>]<span class="c1">;</span>
            <span class="o">*</span><span class="nv">start</span> <span class="o">=</span> <span class="nv">entry</span><span class="o">-&gt;</span><span class="nv">head</span><span class="c1">;</span>
            <span class="o">*</span><span class="k">end</span> <span class="o">=</span> <span class="nv">entry</span><span class="o">-&gt;</span><span class="nv">tail</span><span class="c1">;</span>
            <span class="nv">lock_</span>.<span class="nv">Unlock</span><span class="ss">()</span><span class="c1">;</span>
            <span class="k">return</span> <span class="nv">N</span><span class="c1">;</span>
          }

          <span class="nv">int</span> <span class="nb">result</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">;</span>
          <span class="nv">void</span><span class="o">*</span> <span class="nv">head</span> <span class="o">=</span> <span class="nv">NULL</span><span class="c1">;</span>
          <span class="nv">void</span><span class="o">*</span> <span class="nv">tail</span> <span class="o">=</span> <span class="nv">NULL</span><span class="c1">;</span>
          <span class="o">//</span> <span class="nv">TODO</span>: <span class="nv">Prefetch</span> <span class="nv">multiple</span> <span class="nv">TCEntries</span>?
          <span class="nv">tail</span> <span class="o">=</span> <span class="nv">FetchFromSpansSafe</span><span class="ss">()</span><span class="c1">;</span>
          <span class="k">if</span> <span class="ss">(</span><span class="nv">tail</span> <span class="o">!=</span> <span class="nv">NULL</span><span class="ss">)</span> {
            <span class="nv">SLL_SetNext</span><span class="ss">(</span><span class="nv">tail</span>, <span class="nv">NULL</span><span class="ss">)</span><span class="c1">;</span>
            <span class="nv">head</span> <span class="o">=</span> <span class="nv">tail</span><span class="c1">;</span>
            <span class="nb">result</span> <span class="o">=</span> <span class="mi">1</span><span class="c1">;</span>
            <span class="k">while</span> <span class="ss">(</span><span class="nb">result</span> <span class="o">&lt;</span> <span class="nv">N</span><span class="ss">)</span> {
              <span class="nv">void</span> <span class="o">*</span><span class="nv">t</span> <span class="o">=</span> <span class="nv">FetchFromSpans</span><span class="ss">()</span><span class="c1">;</span>
              <span class="k">if</span> <span class="ss">(</span><span class="o">!</span><span class="nv">t</span><span class="ss">)</span> <span class="k">break</span><span class="c1">;</span>
              <span class="nv">SLL_Push</span><span class="ss">(</span><span class="o">&amp;</span><span class="nv">head</span>, <span class="nv">t</span><span class="ss">)</span><span class="c1">;</span>
              <span class="nb">result</span><span class="o">++</span><span class="c1">;</span>
            }
          }
          <span class="nv">lock_</span>.<span class="nv">Unlock</span><span class="ss">()</span><span class="c1">;</span>
          <span class="o">*</span><span class="nv">start</span> <span class="o">=</span> <span class="nv">head</span><span class="c1">;</span>
          <span class="o">*</span><span class="k">end</span> <span class="o">=</span> <span class="nv">tail</span><span class="c1">;</span>
          <span class="k">return</span> <span class="nb">result</span><span class="c1">;</span>
        }

        <span class="nv">int</span> <span class="nv">SizeMap</span>::<span class="nv">NumMoveSize</span><span class="ss">(</span><span class="nv">size_t</span> <span class="nv">size</span><span class="ss">)</span> {
          <span class="k">if</span> <span class="ss">(</span><span class="nv">size</span> <span class="o">==</span> <span class="mi">0</span><span class="ss">)</span> <span class="k">return</span> <span class="mi">0</span><span class="c1">;</span>

          <span class="nv">int</span> <span class="nv">num</span> <span class="o">=</span> <span class="nv">static_cast</span><span class="o">&lt;</span><span class="nv">int</span><span class="o">&gt;</span><span class="ss">(</span><span class="mi">64</span>.<span class="mi">0</span> <span class="o">*</span> <span class="mi">1024</span>.<span class="mi">0</span> <span class="o">/</span> <span class="nv">size</span><span class="ss">)</span><span class="c1">;</span>
          <span class="k">if</span> <span class="ss">(</span><span class="nv">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="ss">)</span> <span class="nv">num</span> <span class="o">=</span> <span class="mi">2</span><span class="c1">;</span>

          <span class="k">if</span> <span class="ss">(</span><span class="nv">num</span> <span class="o">&gt;</span> <span class="nv">FLAGS_tcmalloc_transfer_num_objects</span><span class="ss">)</span>
            <span class="nv">num</span> <span class="o">=</span> <span class="nv">FLAGS_tcmalloc_transfer_num_objects</span><span class="c1">;</span>

          <span class="k">return</span> <span class="nv">num</span><span class="c1">;</span>
        }
```

<span class="o">*</span> <span class="nv">TC</span>向<span class="nv">CC</span>释放内存
    <span class="nv">TC</span>向<span class="nv">CC</span>释放内存的条件是,在进程向<span class="nv">TC</span>释放内存时,<span class="nv">TC</span>对应的分类<span class="nv">free</span> <span class="nv">list</span>的 `<span class="nv">length</span> <span class="o">&gt;</span> <span class="nv">max_length</span>` 或者 <span class="nv">TC</span>的总 `<span class="nv">size</span> <span class="o">&gt;</span> <span class="nv">max_size</span>`, 分别触发<span class="nv">ListTooLong</span>和<span class="nv">Scavenge</span>内存回收.

    <span class="nv">ListTooLong</span> 回收内存规则:

        <span class="o">*</span> 如果 `<span class="nv">list</span> <span class="nv">length</span> <span class="o">&lt;</span> <span class="nv">batch_size</span>` ,则清空链表. 这种情况下,只有非频繁内存请求,才会 `<span class="nv">length</span> <span class="o">&lt;</span> <span class="nv">batch_size</span>`, 所以, 在时间和空间上,考虑优先空间,释放内存.
        <span class="o">*</span> 如果 `<span class="nv">list</span> <span class="nv">length</span> <span class="o">&gt;</span> <span class="nv">batch_size</span>`, 则释放 `<span class="nv">batch_size</span>` 个<span class="nv">object</span>.并且减少<span class="nv">list</span>的<span class="nv">max</span> <span class="nv">length</span>, 尽可能利用慢启动, 减少空间浪费的问题.

    <span class="nv">Scavenge</span>回收内存规则:

        <span class="o">*</span> 遍历<span class="nv">TC</span>中所有的<span class="nv">free</span> <span class="nv">list</span>, 将<span class="ss">(</span><span class="nv">lowwatermark</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span>的<span class="nv">list</span> 释放 <span class="ss">(</span><span class="nv">lowwatermark</span> <span class="o">/</span> <span class="mi">2</span> <span class="ss">)</span>个<span class="nv">objects</span>.
        <span class="o">*</span> 如果<span class="nv">lowwatermark</span> <span class="o">&gt;</span> <span class="mi">0</span>的 `<span class="nv">list</span> <span class="nv">length</span> <span class="o">&gt;</span> <span class="nv">batch_size</span>`, 则更新`<span class="nv">max_length</span>` 为 `<span class="nv">max_length</span> <span class="o">-</span> <span class="nv">batch_size</span>`, 利用慢启动算法,减慢内存增长的速度.
        <span class="o">*</span> 重置所有<span class="nv">list</span>的 <span class="nv">lowwatermark</span>为当前的<span class="nv">length</span>.<span class="ss">(</span><span class="nv">lowwatermark</span>会在<span class="nv">list</span>的<span class="nv">length</span>减小时更新,始终保持为<span class="nv">list</span>最小的<span class="nv">length</span><span class="ss">)</span>.
        <span class="o">*</span> 偷取其他<span class="nv">TC</span>的 `<span class="nv">max_length</span>`.由于当前<span class="nv">TC</span>容量不够,所以,偷取其他<span class="nv">TC</span>容
        量,保证无用线程不会浪费过多空间.

    <span class="nv">TC</span>容量偷取:

        <span class="o">*</span> 如果存在无人认领的内存<span class="ss">(</span>无人认领内存:线程结束后<span class="ss">(</span><span class="nv">TC</span>的<span class="nv">Heap</span>被释放<span class="ss">)</span>的内存, 最大为 <span class="mi">8</span><span class="nv">u</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="ss">)</span>,则优先从其领取需要的内存,增大当前线程的容量.
        <span class="o">*</span> 上述条件不满足,则遍历所有的<span class="nv">TC</span>, 如果某个<span class="nv">TC</span>的容量 <span class="o">&gt;</span> <span class="nv">kMinThreadCacheSize</span> <span class="ss">(</span><span class="nv">kMaxSize</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">512</span><span class="nv">K</span><span class="ss">)</span> , 则偷取其容量.

    ```<span class="nv">cpp</span>        
        <span class="nv">void</span> <span class="nv">ThreadCache</span>::<span class="nv">ListTooLong</span><span class="ss">(</span><span class="nv">FreeList</span><span class="o">*</span> <span class="nv">list</span>, <span class="nv">size_t</span> <span class="nv">cl</span><span class="ss">)</span> {
          <span class="nv">const</span> <span class="nv">int</span> <span class="nv">batch_size</span> <span class="o">=</span> <span class="nv">Static</span>::<span class="nv">sizemap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">num_objects_to_move</span><span class="ss">(</span><span class="nv">cl</span><span class="ss">)</span><span class="c1">;</span>
          <span class="o">//</span> 如果<span class="nv">list</span>长度小于 <span class="nv">batch_size</span>, 释放所有, 否则, 释放<span class="nv">batch_size</span>个块.
          <span class="nv">ReleaseToCentralCache</span><span class="ss">(</span><span class="nv">list</span>, <span class="nv">cl</span>, <span class="nv">batch_size</span><span class="ss">)</span><span class="c1">;</span>

          <span class="k">if</span> <span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">&lt;</span> <span class="nv">batch_size</span><span class="ss">)</span> {
            <span class="o">//</span> <span class="nv">Slow</span> <span class="nv">start</span> <span class="nv">the</span> <span class="nv">max_length</span> <span class="nv">so</span> <span class="nv">we</span> <span class="nv">don</span><span class="s1">&#39;</span><span class="s">t overreserve.</span>
            <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">set_max_length</span><span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">+</span> <span class="mi">1</span><span class="ss">)</span><span class="c1">;</span>
          } <span class="k">else</span> <span class="k">if</span> <span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">&gt;</span> <span class="nv">batch_size</span><span class="ss">)</span> {
            <span class="o">//</span> <span class="k">If</span> <span class="nv">we</span> <span class="nv">consistently</span> <span class="nv">go</span> <span class="nv">over</span> <span class="nv">max_length</span>, <span class="nv">shrink</span> <span class="nv">max_length</span>.  <span class="k">If</span> <span class="nv">we</span> <span class="nv">don</span><span class="s1">&#39;</span><span class="s">t</span>
            <span class="o">//</span> <span class="nv">shrink</span> <span class="nv">it</span>, <span class="nv">some</span> <span class="nv">amount</span> <span class="nv">of</span> <span class="nv">memory</span> <span class="nv">will</span> <span class="nv">always</span> <span class="nv">stay</span> <span class="nv">in</span> <span class="nv">this</span> <span class="nv">freelist</span>.
            <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">set_length_overages</span><span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">length_overages</span><span class="ss">()</span> <span class="o">+</span> <span class="mi">1</span><span class="ss">)</span><span class="c1">;</span>
            <span class="k">if</span> <span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">length_overages</span><span class="ss">()</span> <span class="o">&gt;</span> <span class="nv">kMaxOverages</span><span class="ss">)</span> {
              <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">&gt;</span> <span class="nv">batch_size</span><span class="ss">)</span><span class="c1">;</span>
              <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">set_max_length</span><span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">-</span> <span class="nv">batch_size</span><span class="ss">)</span><span class="c1">;</span>
              <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">set_length_overages</span><span class="ss">(</span><span class="mi">0</span><span class="ss">)</span><span class="c1">;</span>
            }
          }
        }
    ```

    <span class="nv">ReleaseToCentralCache</span>中执行了,将链表返回给<span class="nv">CC</span>的动作,里面涉及到了<span class="nv">slots</span>结构,我们来看下.

    ```
        <span class="o">//</span> <span class="nv">Remove</span> <span class="nv">some</span> <span class="nv">objects</span> <span class="nv">of</span> <span class="nv">class</span> <span class="s2">&quot;</span><span class="s">cl</span><span class="s2">&quot;</span> <span class="nv">from</span> <span class="nv">thread</span> <span class="nv">heap</span> <span class="nv">and</span> <span class="nv">add</span> <span class="nv">to</span> <span class="nv">central</span> <span class="nv">cache</span>
        <span class="nv">void</span> <span class="nv">ThreadCache</span>::<span class="nv">ReleaseToCentralCache</span><span class="ss">(</span><span class="nv">FreeList</span><span class="o">*</span> <span class="nv">src</span>, <span class="nv">size_t</span> <span class="nv">cl</span>, <span class="nv">int</span> <span class="nv">N</span><span class="ss">)</span> {
          <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">src</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nv">list_</span>[<span class="nv">cl</span>]<span class="ss">)</span><span class="c1">;</span>
          <span class="k">if</span> <span class="ss">(</span><span class="nv">N</span> <span class="o">&gt;</span> <span class="nv">src</span><span class="o">-&gt;</span><span class="nv">length</span><span class="ss">())</span> <span class="nv">N</span> <span class="o">=</span> <span class="nv">src</span><span class="o">-&gt;</span><span class="nv">length</span><span class="ss">()</span><span class="c1">;</span>
          <span class="nv">size_t</span> <span class="nv">delta_bytes</span> <span class="o">=</span> <span class="nv">N</span> <span class="o">*</span> <span class="nv">Static</span>::<span class="nv">sizemap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">ByteSizeForClass</span><span class="ss">(</span><span class="nv">cl</span><span class="ss">)</span><span class="c1">;</span>

          <span class="o">//</span> <span class="nv">We</span> <span class="k">return</span> <span class="nv">prepackaged</span> <span class="nv">chains</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">correct</span> <span class="nv">size</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">central</span> <span class="nv">cache</span>.
          <span class="o">//</span> <span class="nv">TODO</span>: <span class="nv">Use</span> <span class="nv">the</span> <span class="nv">same</span> <span class="nv">format</span> <span class="nv">internally</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">thread</span> <span class="nv">caches</span>?
          <span class="nv">int</span> <span class="nv">batch_size</span> <span class="o">=</span> <span class="nv">Static</span>::<span class="nv">sizemap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">num_objects_to_move</span><span class="ss">(</span><span class="nv">cl</span><span class="ss">)</span><span class="c1">;</span>
          <span class="k">while</span> <span class="ss">(</span><span class="nv">N</span> <span class="o">&gt;</span> <span class="nv">batch_size</span><span class="ss">)</span> {
            <span class="nv">void</span> <span class="o">*</span><span class="nv">tail</span>, <span class="o">*</span><span class="nv">head</span><span class="c1">;</span>
            <span class="nv">src</span><span class="o">-&gt;</span><span class="nv">PopRange</span><span class="ss">(</span><span class="nv">batch_size</span>, <span class="o">&amp;</span><span class="nv">head</span>, <span class="o">&amp;</span><span class="nv">tail</span><span class="ss">)</span><span class="c1">;</span>
            <span class="nv">Static</span>::<span class="nv">central_cache</span><span class="ss">()</span>[<span class="nv">cl</span>].<span class="nv">InsertRange</span><span class="ss">(</span><span class="nv">head</span>, <span class="nv">tail</span>, <span class="nv">batch_size</span><span class="ss">)</span><span class="c1">;</span>
            <span class="nv">N</span> <span class="o">-=</span> <span class="nv">batch_size</span><span class="c1">;</span>
          }
          <span class="nv">void</span> <span class="o">*</span><span class="nv">tail</span>, <span class="o">*</span><span class="nv">head</span><span class="c1">;</span>
          <span class="nv">src</span><span class="o">-&gt;</span><span class="nv">PopRange</span><span class="ss">(</span><span class="nv">N</span>, <span class="o">&amp;</span><span class="nv">head</span>, <span class="o">&amp;</span><span class="nv">tail</span><span class="ss">)</span><span class="c1">;</span>
          <span class="nv">Static</span>::<span class="nv">central_cache</span><span class="ss">()</span>[<span class="nv">cl</span>].<span class="nv">InsertRange</span><span class="ss">(</span><span class="nv">head</span>, <span class="nv">tail</span>, <span class="nv">N</span><span class="ss">)</span><span class="c1">;</span>
          <span class="nv">size_</span> <span class="o">-=</span> <span class="nv">delta_bytes</span><span class="c1">;</span>
        }
    ```

    这个函数实际上是从<span class="nv">TC</span>释放到<span class="nv">CC</span>时调用.

    ```
        <span class="nv">void</span> <span class="nv">CentralFreeList</span>::<span class="nv">InsertRange</span><span class="ss">(</span><span class="nv">void</span> <span class="o">*</span><span class="nv">start</span>, <span class="nv">void</span> <span class="o">*</span><span class="k">end</span>, <span class="nv">int</span> <span class="nv">N</span><span class="ss">)</span> {
          <span class="nv">SpinLockHolder</span> <span class="nv">h</span><span class="ss">(</span><span class="o">&amp;</span><span class="nv">lock_</span><span class="ss">)</span><span class="c1">;</span>
          <span class="k">if</span> <span class="ss">(</span><span class="nv">N</span> <span class="o">==</span> <span class="nv">Static</span>::<span class="nv">sizemap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">num_objects_to_move</span><span class="ss">(</span><span class="nv">size_class_</span><span class="ss">)</span> <span class="o">&amp;&amp;</span>
            <span class="nv">MakeCacheSpace</span><span class="ss">())</span> {
            <span class="o">//</span> <span class="nv">slots</span> 是存在<span class="nv">CC</span> 的链表中的结构.
            <span class="o">//</span> 每个<span class="nv">CC</span>的链表节点是<span class="nv">slots</span>.
            <span class="o">//</span> 每个<span class="nv">slots</span>中的数据正好是<span class="nv">TC</span>中移动数据的大小.
            <span class="nv">int</span> <span class="nv">slot</span> <span class="o">=</span> <span class="nv">used_slots_</span><span class="o">++</span><span class="c1">;</span>
            <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">slot</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="ss">)</span><span class="c1">;</span>
            <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">slot</span> <span class="o">&lt;</span> <span class="nv">max_cache_size_</span><span class="ss">)</span><span class="c1">;</span>
            <span class="nv">TCEntry</span> <span class="o">*</span><span class="nv">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">tc_slots_</span>[<span class="nv">slot</span>]<span class="c1">;</span>
            <span class="nv">entry</span><span class="o">-&gt;</span><span class="nv">head</span> <span class="o">=</span> <span class="nv">start</span><span class="c1">;</span>
            <span class="nv">entry</span><span class="o">-&gt;</span><span class="nv">tail</span> <span class="o">=</span> <span class="k">end</span><span class="c1">;</span>
            <span class="k">return</span><span class="c1">;</span>
          }
          <span class="nv">ReleaseListToSpans</span><span class="ss">(</span><span class="nv">start</span><span class="ss">)</span><span class="c1">;</span>
        }
    ```

    ```
        <span class="nv">void</span> <span class="nv">ThreadCache</span>::<span class="nv">Scavenge</span><span class="ss">()</span> {
          <span class="o">//</span> <span class="k">If</span> <span class="nv">the</span> <span class="nv">low</span><span class="o">-</span><span class="nv">water</span> <span class="nv">mark</span> <span class="k">for</span> <span class="nv">the</span> <span class="nv">free</span> <span class="nv">list</span> <span class="nv">is</span> <span class="nv">L</span>, <span class="nv">it</span> <span class="nv">means</span> <span class="nv">we</span> <span class="nv">would</span>
          <span class="o">//</span> <span class="nv">not</span> <span class="nv">have</span> <span class="nv">had</span> <span class="nv">to</span> <span class="nv">allocate</span> <span class="nv">anything</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">central</span> <span class="nv">cache</span> <span class="nv">even</span> <span class="k">if</span>
          <span class="o">//</span> <span class="nv">we</span> <span class="nv">had</span> <span class="nv">reduced</span> <span class="nv">the</span> <span class="nv">free</span> <span class="nv">list</span> <span class="nv">size</span> <span class="nv">by</span> <span class="nv">L</span>.  <span class="nv">We</span> <span class="nv">aim</span> <span class="nv">to</span> <span class="nv">get</span> <span class="nv">closer</span> <span class="nv">to</span>
          <span class="o">//</span> <span class="nv">that</span> <span class="nv">situation</span> <span class="nv">by</span> <span class="nv">dropping</span> <span class="nv">L</span><span class="o">/</span><span class="mi">2</span> <span class="nv">nodes</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">free</span> <span class="nv">list</span>.  <span class="nv">This</span>
          <span class="o">//</span> <span class="nv">may</span> <span class="nv">not</span> <span class="nv">release</span> <span class="nv">much</span> <span class="nv">memory</span>, <span class="nv">but</span> <span class="k">if</span> <span class="nv">so</span> <span class="nv">we</span> <span class="nv">will</span> <span class="k">call</span> <span class="nl">scavenge</span> <span class="nv">again</span>
          <span class="o">//</span> <span class="nv">pretty</span> <span class="nv">soon</span> <span class="nv">and</span> <span class="nv">the</span> <span class="nv">low</span><span class="o">-</span><span class="nv">water</span> <span class="nv">marks</span> <span class="nv">will</span> <span class="nv">be</span> <span class="nv">high</span> <span class="nv">on</span> <span class="nv">that</span> <span class="nv">call</span>.
          <span class="o">//</span><span class="nv">int64</span> <span class="nv">start</span> <span class="o">=</span> <span class="nv">CycleClock</span>::<span class="nv">Now</span><span class="ss">()</span><span class="c1">;</span>
          <span class="k">for</span> <span class="ss">(</span><span class="nv">int</span> <span class="nv">cl</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">; cl &lt; kNumClasses; cl++) {</span>
            <span class="nv">FreeList</span><span class="o">*</span> <span class="nv">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">list_</span>[<span class="nv">cl</span>]<span class="c1">;</span>
            <span class="nv">const</span> <span class="nv">int</span> <span class="nv">lowmark</span> <span class="o">=</span> <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">lowwatermark</span><span class="ss">()</span><span class="c1">;</span>
            <span class="o">//</span> 首先清理 <span class="nv">lowmark</span> <span class="o">&gt;</span> <span class="mi">0</span> 的.就算某些<span class="nv">lowmark</span>值不对, 在该轮结束后,会通过<span class="nv">clear_lowwatermark</span><span class="ss">()</span>重置,下一次将会成功释放大量内存.
            <span class="k">if</span> <span class="ss">(</span><span class="nv">lowmark</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span> {
              <span class="nv">const</span> <span class="nv">int</span> <span class="nv">drop</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">lowmark</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="ss">)</span> ? <span class="nv">lowmark</span><span class="o">/</span><span class="mi">2</span> : <span class="mi">1</span><span class="c1">;</span>
              <span class="nv">ReleaseToCentralCache</span><span class="ss">(</span><span class="nv">list</span>, <span class="nv">cl</span>, <span class="nv">drop</span><span class="ss">)</span><span class="c1">;</span>

              <span class="o">//</span> <span class="nv">Shrink</span> <span class="nv">the</span> <span class="nv">max</span> <span class="nv">length</span> <span class="k">if</span> <span class="nv">it</span> <span class="nv">isn</span><span class="s1">&#39;</span><span class="s">t used.  Only shrink down to</span>
              <span class="o">//</span> <span class="nv">batch_size</span> <span class="o">--</span> <span class="k">if</span> <span class="nv">the</span> <span class="nv">thread</span> <span class="nv">was</span> <span class="nv">active</span> <span class="nv">enough</span> <span class="nv">to</span> <span class="nv">get</span> <span class="nv">the</span> <span class="nv">max_length</span>
              <span class="o">//</span> <span class="nv">above</span> <span class="nv">batch_size</span>, <span class="nv">it</span> <span class="nv">will</span> <span class="nv">likely</span> <span class="nv">be</span> <span class="nv">that</span> <span class="nv">active</span> <span class="nv">again</span>.  <span class="k">If</span>
              <span class="o">//</span> <span class="nv">max_length</span> <span class="nv">shinks</span> <span class="nv">below</span> <span class="nv">batch_size</span>, <span class="nv">the</span> <span class="nv">thread</span> <span class="nv">will</span> <span class="nv">have</span> <span class="nv">to</span>
              <span class="o">//</span> <span class="nv">go</span> <span class="nv">through</span> <span class="nv">the</span> <span class="nv">slow</span><span class="o">-</span><span class="nv">start</span> <span class="nv">behavior</span> <span class="nv">again</span>.  <span class="nv">The</span> <span class="nv">slow</span><span class="o">-</span><span class="nv">start</span> <span class="nv">is</span> <span class="nv">useful</span>
              <span class="o">//</span> <span class="nv">mainly</span> <span class="k">for</span> <span class="nv">threads</span> <span class="nv">that</span> <span class="nv">stay</span> <span class="nv">relatively</span> <span class="nv">idle</span> <span class="k">for</span> <span class="nv">their</span> <span class="nv">entire</span>
              <span class="o">//</span> <span class="nv">lifetime</span>.
              <span class="o">//</span> 由于该<span class="nv">TC</span>内存快满了,所以,我们减少<span class="nv">batch_size</span>, 减慢慢启动算法,保证空间不会浪费太多.
              <span class="nv">const</span> <span class="nv">int</span> <span class="nv">batch_size</span> <span class="o">=</span> <span class="nv">Static</span>::<span class="nv">sizemap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">num_objects_to_move</span><span class="ss">(</span><span class="nv">cl</span><span class="ss">)</span><span class="c1">;</span>
              <span class="k">if</span> <span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">&gt;</span> <span class="nv">batch_size</span><span class="ss">)</span> {
                <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">set_max_length</span><span class="ss">(</span>
                    <span class="nv">max</span><span class="o">&lt;</span><span class="nv">int</span><span class="o">&gt;</span><span class="ss">(</span><span class="nv">list</span><span class="o">-&gt;</span><span class="nv">max_length</span><span class="ss">()</span> <span class="o">-</span> <span class="nv">batch_size</span>, <span class="nv">batch_size</span><span class="ss">))</span><span class="c1">; // 减少后和batch_size中的最大值.</span>
              }
            }
            <span class="nv">list</span><span class="o">-&gt;</span><span class="nv">clear_lowwatermark</span><span class="ss">()</span><span class="c1">;  //清理低水平标志位.其实就是设置为当前长度...</span>
          }
          <span class="o">//</span> 无耻地偷取其他线程的容量.
          <span class="nv">IncreaseCacheLimit</span><span class="ss">()</span><span class="c1">;</span>
        }
    ```

    以上是内存释放的情况,还有个保证自己线程容量充裕的无耻做法是,偷取其他线程的容量.偷取临近<span class="mi">10</span>个<span class="nv">TC</span>的 <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>容量. 当然,如果其容量小于最小值,就放过了．也就是说,对于很少启动慢启动的线程,其线程容量将会由于被偷取而持续减少, 有效控制了这种线程内存的浪费,通过这种机制,有效地保证进程间空间不会浪费太多. 需求大的线程可以获得更多的容量,而需求小的线程获取少的容量.如果存在无人认领的内存,咱们就偷了<span class="o">!!</span>所谓无人认领的内存,是指线程被释放后, 其释放的内存.

    ```<span class="nv">cpp</span>
        <span class="nv">void</span> <span class="nv">ThreadCache</span>::<span class="nv">IncreaseCacheLimitLocked</span><span class="ss">()</span> {
          <span class="k">if</span> <span class="ss">(</span><span class="nv">unclaimed_cache_space_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span> {
            <span class="o">//</span> <span class="nv">Possibly</span> <span class="nv">make</span> <span class="nv">unclaimed_cache_space_</span> <span class="nv">negative</span>.
            <span class="nv">unclaimed_cache_space_</span> <span class="o">-=</span> <span class="nv">kStealAmount</span><span class="c1">;</span>
            <span class="nv">max_size_</span> <span class="o">+=</span> <span class="nv">kStealAmount</span><span class="c1">;</span>
            <span class="k">return</span><span class="c1">;</span>
          }
          <span class="o">//</span> <span class="nv">Don</span><span class="s1">&#39;</span><span class="s">t hold pageheap_lock too long.  Try to steal from 10 other</span>
          <span class="o">//</span> <span class="nv">threads</span> <span class="nv">before</span> <span class="nv">giving</span> <span class="nv">up</span>.  <span class="nv">The</span> <span class="nv">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="nv">condition</span> <span class="nv">also</span> <span class="nv">prevents</span> <span class="nv">an</span>
          <span class="o">//</span> <span class="nv">infinite</span> <span class="k">loop</span> <span class="nv">in</span> <span class="nv">case</span> <span class="nv">none</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">existing</span> <span class="nv">thread</span> <span class="nv">heaps</span> <span class="nv">are</span>
          <span class="o">//</span> <span class="nv">suitable</span> <span class="nv">places</span> <span class="nv">to</span> <span class="nv">steal</span> <span class="nv">from</span>.
          <span class="k">for</span> <span class="ss">(</span><span class="nv">int</span> <span class="nv">i</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">; i &lt; 10;</span>
               <span class="o">++</span><span class="nv">i</span>, <span class="nv">next_memory_steal_</span> <span class="o">=</span> <span class="nv">next_memory_steal_</span><span class="o">-&gt;</span><span class="nv">next_</span><span class="ss">)</span> {
            <span class="o">//</span> <span class="nv">Reached</span> <span class="nv">the</span> <span class="k">end</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">linked</span> <span class="nv">list</span>.  <span class="nv">Start</span> <span class="nv">at</span> <span class="nv">the</span> <span class="nv">beginning</span>.
            <span class="k">if</span> <span class="ss">(</span><span class="nv">next_memory_steal_</span> <span class="o">==</span> <span class="nv">NULL</span><span class="ss">)</span> {
              <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">thread_heaps_</span> <span class="o">!=</span> <span class="nv">NULL</span><span class="ss">)</span><span class="c1">;</span>
              <span class="o">//</span> <span class="nv">next_memory_steal_</span> 在初始化时默认为<span class="nv">TC</span>的<span class="nv">Heap</span>的链表头.
              <span class="o">//</span> 所以,这个循环会不停轮流偷取链表里的所有线程,包括自己.
              <span class="nv">next_memory_steal_</span> <span class="o">=</span> <span class="nv">thread_heaps_</span><span class="c1">;</span>
            }
            <span class="k">if</span> <span class="ss">(</span><span class="nv">next_memory_steal_</span> <span class="o">==</span> <span class="nv">this</span> <span class="o">||</span>
                <span class="nv">next_memory_steal_</span><span class="o">-&gt;</span><span class="nv">max_size_</span> <span class="o">&lt;=</span> <span class="nv">kMinThreadCacheSize</span><span class="ss">)</span> {
              <span class="k">continue</span><span class="c1">;</span>
            }
            <span class="nv">next_memory_steal_</span><span class="o">-&gt;</span><span class="nv">max_size_</span> <span class="o">-=</span> <span class="nv">kStealAmount</span><span class="c1">;</span>
            <span class="nv">max_size_</span> <span class="o">+=</span> <span class="nv">kStealAmount</span><span class="c1">;</span>

            <span class="nv">next_memory_steal_</span> <span class="o">=</span> <span class="nv">next_memory_steal_</span><span class="o">-&gt;</span><span class="nv">next_</span><span class="c1">;</span>
            <span class="k">return</span><span class="c1">;</span>
          }
        }
    ```
</pre></div>


<ul>
<li>
<p>CC向PH 申请和释放内存</p>
<ul>
<li>
<p>PH的内存管理</p>
<p>PH的管理,跟TC一样也是进行了分类,挺复杂的.首先, 所有的内存,映射到进程空间的内存,都会占据着PH中的某个list. PH的内存是直接从系统的sbrk或者mmap分配的.同样, 大内存也是从PH分配的,所以,它很复杂!</p>
<p>PH的分类,是按page数量进行. <code>free_</code> 从 <code>0 - kMaxPages</code>, 每个数组成员包含数组下标个pages, 也就是 <code>free_</code>包含1个page长度的Spans.每个数组成员包含2个双向环形链表normal和returned.而大于kMaxPages的归属到large&ensp;中.</p>
<p>normal: 存放空闲的span list.</p>
<p>returned: 存放通过madvise的 <code>MADV_FREE</code> 方式释放的span.前提时系统支持 <code>MADV_FREE</code> 或 <code>MADV_DONTNEED</code> 否则就不释放内存.</p>
<p>所谓madvise的<code>MADV_FREE</code> 释放内存, 是内核实现的一种lazy free方式.在process通过 madvise<code>MADV_FREE</code> 方式通知kernel, 某段pages中的数据不再使用了,如果kernel需要,可以清楚.如果process先于kernel再次访问了该区域,process可以快速获取到该位置的原先数据. 如果kernel先于process需要该pages,则当process访问时,会获得被清空的pages.</p>
<p>如果我们系统不支持<code>MADV_FREE</code>, 则使用<code>MADV_DONTNEED</code>. <code>MADV_DONTNEED</code>与<code>MADV_FREE</code>的区别在于,<code>MADV_DONTNEED</code>的情况下,不管什么情况下再次访问这段pages, 获得的总是被清0的内存区域.</p>
<p><a href="http://www.gossamer-threads.com/lists/linux/kernel/762930">more info about MADV_FREE and MADV_DONTNEED</a></p>
<p>对于span, span中objects的地址和 span的PageID之间, 在PH中存在相应的算法进行映射. PageMap 是一个基数树(radix tree), 能将某个地址映射到对应的span. 而PageMapCache是HashTable能将对应的PageId映射到其size class.</p>
<p>```
    // We segregate spans of a given size into two circular linked
    // lists: one for normal spans, and one for spans whose memory
    // has been returned to the system.
    struct SpanList {
      Span        normal;    // 存放被映射到进程空间的spans..
      Span        returned;  // 存放已经被释放回系统的spans..(?)
    };</p>
<div class="codehilite"><pre><span></span><span class="o">//</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">free</span><span class="w"> </span><span class="n">spans</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">kMaxPages</span><span class="w"></span>
<span class="n">SpanList</span><span class="w"> </span><span class="n">large_</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">所有</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="n">pages的spans</span><span class="p">,</span><span class="w"> </span><span class="n">都归属到该list</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="k">Array</span><span class="w"> </span><span class="n">mapping</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">span</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">doubly</span><span class="w"> </span><span class="n">linked</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">free</span><span class="w"> </span><span class="n">spans</span><span class="w"></span>
<span class="n">SpanList</span><span class="w"> </span><span class="n">free_</span><span class="o">[</span><span class="n">kMaxPages</span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">kMaxPages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="mi">20</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kPageShift</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">);</span><span class="w"> </span><span class="n">也就是说有128个分类</span><span class="p">.</span><span class="w"></span>
</pre></div>


<p>```</p>
</li>
<li>
<p>CC 向PH 内存申请</p>
<p>CC向PH申请内存的条件是,当前CentralFreeList中空闲span不够.所有向PH申请的内存都是Page的N倍,所以,参数是N. PageHeap::New(Length n).</p>
<div class="codehilite"><pre><span></span><span class="o">*</span> <span class="err">首先</span><span class="p">,</span> <span class="err">搜索所有</span> <span class="o">&gt;=</span> <span class="n">N</span> <span class="p">(</span><span class="n">N</span> <span class="o">&lt;=</span> <span class="n">kMaxPages</span><span class="p">)</span><span class="err">的</span><span class="k">free</span> <span class="n">list</span><span class="p">,</span> <span class="err">查找最符合要求的</span><span class="n">span</span><span class="p">.</span><span class="err">如果找到</span><span class="p">,</span><span class="err">则直接从双向链表中删除</span><span class="p">.</span> <span class="err">如果</span><span class="n">span比要求的大</span><span class="p">,</span><span class="err">则切分</span><span class="p">(</span><span class="n">Carve</span><span class="p">),</span><span class="err">将剩下的新申请一个</span><span class="n">span</span><span class="p">,</span><span class="err">放入对应的</span><span class="k">size</span> <span class="n">class中</span><span class="p">.</span><span class="err">这种算法查找最适合的</span><span class="p">,</span><span class="err">但会导致地址不连续</span><span class="p">.</span>
<span class="o">*</span> <span class="err">如果所有的</span><span class="k">free</span> <span class="n">list中没有匹配的</span><span class="p">,</span><span class="err">则遍历</span><span class="k">large</span> <span class="n">list</span><span class="p">.</span><span class="err">由于</span><span class="k">large</span> <span class="n">list中是未排序的</span><span class="p">,</span> <span class="err">所以</span><span class="p">,</span> <span class="err">在搜索时</span><span class="p">,</span> <span class="err">需要不停地记录最接近请求大小的</span><span class="n">span</span><span class="p">.</span> <span class="err">所以该算法是</span><span class="n">O</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="err">费时</span><span class="p">.</span>
<span class="o">*</span> <span class="err">如果以上查找都失败</span><span class="p">,</span><span class="err">则</span><span class="n">PH就向系统申请N</span> <span class="n">pages</span> <span class="err">并存入对应的</span><span class="k">size</span> <span class="k">class</span><span class="p">.</span><span class="err">然后从头开始</span><span class="p">.</span><span class="err">如果申请失败</span><span class="p">,</span><span class="err">则返回</span><span class="k">NULL</span><span class="p">.</span>
</pre></div>


<p>我们延续之前TC向CC请求内存时的情况,在slots不够时,会向spans请求.如下代码:</p>
<p>```
    void<em> CentralFreeList::FetchFromSpansSafe() {
      // 第一次尝试,如果失败,则意味着spans空间不够,需要向PH申请内存.
      void </em>t = FetchFromSpans();
      if (!t) {
        // 向PH申请内存,并划分获取的spans,用于该分类的slots.
        Populate();
        // 再次尝试获取objects.
        t = FetchFromSpans();
      }
      return t;
    }</p>
<div class="codehilite"><pre><span></span><span class="o">//</span> <span class="nv">Fetch</span> <span class="nv">memory</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">system</span> <span class="nv">and</span> <span class="nv">add</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">central</span> <span class="nv">cache</span> <span class="nv">freelist</span>.
<span class="nv">void</span> <span class="nv">CentralFreeList</span>::<span class="nv">Populate</span><span class="ss">()</span> {
  <span class="o">//</span> <span class="nv">Release</span> <span class="nv">central</span> <span class="nv">list</span> <span class="nv">lock</span> <span class="k">while</span> <span class="nv">operating</span> <span class="nv">on</span> <span class="nv">pageheap</span>
  <span class="nv">lock_</span>.<span class="nv">Unlock</span><span class="ss">()</span><span class="c1">;</span>
  <span class="o">//</span> 获取该类别对应的需要从<span class="nv">PH</span>获取的<span class="nv">page</span>数量.具体数值可以参考上面<span class="nv">slots</span>分类的数据.
  <span class="nv">const</span> <span class="nv">size_t</span> <span class="nv">npages</span> <span class="o">=</span> <span class="nv">Static</span>::<span class="nv">sizemap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">class_to_pages</span><span class="ss">(</span><span class="nv">size_class_</span><span class="ss">)</span><span class="c1">;</span>

  <span class="nv">Span</span><span class="o">*</span> <span class="nv">span</span><span class="c1">;</span>
  {
    <span class="nv">SpinLockHolder</span> <span class="nv">h</span><span class="ss">(</span><span class="nv">Static</span>::<span class="nv">pageheap_lock</span><span class="ss">())</span><span class="c1">;</span>
    <span class="o">//</span> 从<span class="nv">PH</span> 获取<span class="nv">npages</span>
    <span class="nv">span</span> <span class="o">=</span> <span class="nv">Static</span>::<span class="nv">pageheap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">New</span><span class="ss">(</span><span class="nv">npages</span><span class="ss">)</span><span class="c1">;</span>
    <span class="o">//</span> 将这个<span class="nv">span</span>与该类别在<span class="nv">PH</span>中对应起来.
    <span class="k">if</span> <span class="ss">(</span><span class="nv">span</span><span class="ss">)</span> <span class="nv">Static</span>::<span class="nv">pageheap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">RegisterSizeClass</span><span class="ss">(</span><span class="nv">span</span>, <span class="nv">size_class_</span><span class="ss">)</span><span class="c1">;</span>
  }
  <span class="k">if</span> <span class="ss">(</span><span class="nv">span</span> <span class="o">==</span> <span class="nv">NULL</span><span class="ss">)</span> {
    <span class="nv">Log</span><span class="ss">(</span><span class="nv">kLog</span>, <span class="nv">__FILE__</span>, <span class="nv">__LINE__</span>,
        <span class="s2">&quot;</span><span class="s">tcmalloc: allocation failed</span><span class="s2">&quot;</span>, <span class="nv">npages</span> <span class="o">&lt;&lt;</span> <span class="nv">kPageShift</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">lock_</span>.<span class="nv">Lock</span><span class="ss">()</span><span class="c1">;</span>
    <span class="k">return</span><span class="c1">;</span>
  }
  <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">==</span> <span class="nv">npages</span><span class="ss">)</span><span class="c1">;</span>
  <span class="o">//</span> <span class="nv">Cache</span> <span class="nv">sizeclass</span> <span class="nv">info</span> <span class="nv">eagerly</span>.  <span class="nv">Locking</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">necessary</span>.
  <span class="o">//</span> <span class="ss">(</span><span class="nv">Instead</span> <span class="nv">of</span> <span class="nv">being</span> <span class="nv">eager</span>, <span class="nv">we</span> <span class="nv">could</span> <span class="nv">just</span> <span class="nv">replace</span> <span class="nv">any</span> <span class="nv">stale</span> <span class="nv">info</span>
  <span class="o">//</span> <span class="nv">about</span> <span class="nv">this</span> <span class="nv">span</span>, <span class="nv">but</span> <span class="nv">that</span> <span class="nv">seems</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">no</span> <span class="nv">better</span> <span class="nv">in</span> <span class="nv">practice</span>.<span class="ss">)</span>
  <span class="k">for</span> <span class="ss">(</span><span class="nv">int</span> <span class="nv">i</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">; i &lt; npages; i++) {</span>
    <span class="o">//</span> 将<span class="nv">pages</span>的信息和对应的<span class="nv">size_class</span> 注册到<span class="nv">PH</span>中的<span class="nv">hash</span>表中, 也就是<span class="nv">PageMapCache</span>
    <span class="nv">Static</span>::<span class="nv">pageheap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">CacheSizeClass</span><span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">+</span> <span class="nv">i</span>, <span class="nv">size_class_</span><span class="ss">)</span><span class="c1">;</span>
  }

  <span class="o">//</span> <span class="nv">Split</span> <span class="nv">the</span> <span class="nv">block</span> <span class="nv">into</span> <span class="nv">pieces</span> <span class="nv">and</span> <span class="nv">add</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">free</span><span class="o">-</span><span class="nv">list</span>
  <span class="o">//</span> <span class="nv">TODO</span>: <span class="nv">coloring</span> <span class="nv">of</span> <span class="nv">objects</span> <span class="nv">to</span> <span class="nv">avoid</span> <span class="nv">cache</span> <span class="nv">conflicts</span>?
  <span class="o">//</span> 分割该<span class="nv">span</span>中<span class="nv">objects</span>到当前的<span class="nv">free</span><span class="o">-</span><span class="nv">list</span>中.
  <span class="nv">void</span><span class="o">**</span> <span class="nv">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">objects</span><span class="c1">;</span>
  <span class="nv">char</span><span class="o">*</span> <span class="nv">ptr</span> <span class="o">=</span> <span class="nv">reinterpret_cast</span><span class="o">&lt;</span><span class="nv">char</span><span class="o">*&gt;</span><span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">&lt;&lt;</span> <span class="nv">kPageShift</span><span class="ss">)</span><span class="c1">;</span>
  <span class="nv">char</span><span class="o">*</span> <span class="nv">limit</span> <span class="o">=</span> <span class="nv">ptr</span> <span class="o">+</span> <span class="ss">(</span><span class="nv">npages</span> <span class="o">&lt;&lt;</span> <span class="nv">kPageShift</span><span class="ss">)</span><span class="c1">;</span>
  <span class="nv">const</span> <span class="nv">size_t</span> <span class="nv">size</span> <span class="o">=</span> <span class="nv">Static</span>::<span class="nv">sizemap</span><span class="ss">()</span><span class="o">-&gt;</span><span class="nv">ByteSizeForClass</span><span class="ss">(</span><span class="nv">size_class_</span><span class="ss">)</span><span class="c1">;</span>
  <span class="nv">int</span> <span class="nv">num</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">;</span>
  <span class="k">while</span> <span class="ss">(</span><span class="nv">ptr</span> <span class="o">+</span> <span class="nv">size</span> <span class="o">&lt;=</span> <span class="nv">limit</span><span class="ss">)</span> {
    <span class="o">*</span><span class="nv">tail</span> <span class="o">=</span> <span class="nv">ptr</span><span class="c1">;</span>
    <span class="nv">tail</span> <span class="o">=</span> <span class="nv">reinterpret_cast</span><span class="o">&lt;</span><span class="nv">void</span><span class="o">**&gt;</span><span class="ss">(</span><span class="nv">ptr</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">ptr</span> <span class="o">+=</span> <span class="nv">size</span><span class="c1">;</span>
    <span class="nv">num</span><span class="o">++</span><span class="c1">;</span>
  }
  <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">ptr</span> <span class="o">&lt;=</span> <span class="nv">limit</span><span class="ss">)</span><span class="c1">;</span>
  <span class="o">*</span><span class="nv">tail</span> <span class="o">=</span> <span class="nv">NULL</span><span class="c1">;</span>
  <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">refcount</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">; // No sub-object in use yet</span>

  <span class="o">//</span> <span class="nv">Add</span> <span class="nv">span</span> <span class="nv">to</span> <span class="nv">list</span> <span class="nv">of</span> <span class="nv">non</span><span class="o">-</span><span class="nv">empty</span> <span class="nv">spans</span>
  <span class="nv">lock_</span>.<span class="nv">Lock</span><span class="ss">()</span><span class="c1">;</span>
  <span class="o">//</span> 将该<span class="nv">span</span>添加到<span class="nv">noneempty</span>列表中.
  <span class="nv">tcmalloc</span>::<span class="nv">DLL_Prepend</span><span class="ss">(</span><span class="o">&amp;</span><span class="nv">nonempty_</span>, <span class="nv">span</span><span class="ss">)</span><span class="c1">;</span>
  <span class="o">++</span><span class="nv">num_spans_</span><span class="c1">;</span>
  <span class="nv">counter_</span> <span class="o">+=</span> <span class="nv">num</span><span class="c1">;</span>
}
</pre></div>


<p>```</p>
<p>```
    void<em> CentralFreeList::FetchFromSpans() {
      // 检查nonempty list, 如果为空,意味着没有空闲的span.
      if (tcmalloc::DLL_IsEmpty(&amp;nonempty_)) return NULL;
      Span</em> span = nonempty_.next;</p>
<div class="codehilite"><pre><span></span>  <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">objects</span> <span class="o">!=</span> <span class="nv">NULL</span><span class="ss">)</span><span class="c1">;</span>
  <span class="o">//</span> <span class="nv">span</span>的<span class="nv">refcount</span> 指向被使用次数. 每一次被分配内存,引用<span class="o">++</span>, 释放时引用<span class="o">--</span>. 
  <span class="o">//</span> 在释放时,如果<span class="nv">refcount</span>为<span class="mi">0</span>, 就会释放给<span class="nv">PH</span>.
  <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">refcount</span><span class="o">++</span><span class="c1">;</span>
  <span class="nv">void</span><span class="o">*</span> <span class="nb">result</span> <span class="o">=</span> <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">objects</span><span class="c1">;</span>
  <span class="o">//</span> 加入到链表
  <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">objects</span> <span class="o">=</span> <span class="o">*</span><span class="ss">(</span><span class="nv">reinterpret_cast</span><span class="o">&lt;</span><span class="nv">void</span><span class="o">**&gt;</span><span class="ss">(</span><span class="nb">result</span><span class="ss">))</span><span class="c1">;</span>
  <span class="k">if</span> <span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">objects</span> <span class="o">==</span> <span class="nv">NULL</span><span class="ss">)</span> {
    <span class="o">//</span> <span class="nv">Move</span> <span class="nv">to</span> <span class="nv">empty</span> <span class="nv">list</span>
    <span class="nv">tcmalloc</span>::<span class="nv">DLL_Remove</span><span class="ss">(</span><span class="nv">span</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">tcmalloc</span>::<span class="nv">DLL_Prepend</span><span class="ss">(</span><span class="o">&amp;</span><span class="nv">empty_</span>, <span class="nv">span</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">Event</span><span class="ss">(</span><span class="nv">span</span>, <span class="s1">&#39;</span><span class="s">E</span><span class="s1">&#39;</span>, <span class="mi">0</span><span class="ss">)</span><span class="c1">;</span>
  }
  <span class="nv">counter_</span><span class="o">--</span><span class="c1">;</span>
  <span class="k">return</span> <span class="nb">result</span><span class="c1">;</span>
}
</pre></div>


<p>```</p>
<p>下面,我们看下PH的内存分配, 也就是PageHeap::New(Length n)的逻辑.</p>
<p>```
    Span* PageHeap::New(Length n) {
      ASSERT(Check());
      ASSERT(n &gt; 0);</p>
<div class="codehilite"><pre><span></span>  <span class="o">//</span> 搜索<span class="nv">span</span>规则.
  <span class="nv">Span</span><span class="o">*</span> <span class="nb">result</span> <span class="o">=</span> <span class="nv">SearchFreeAndLargeLists</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="c1">;</span>
  <span class="k">if</span> <span class="ss">(</span><span class="nb">result</span> <span class="o">!=</span> <span class="nv">NULL</span><span class="ss">)</span>
    <span class="k">return</span> <span class="nb">result</span><span class="c1">;</span>

  <span class="o">//</span> ...

  <span class="o">//</span> 增长内存, 实际是执行系统调用
  <span class="o">//</span> <span class="nv">Grow</span> <span class="nv">the</span> <span class="nv">heap</span> <span class="nv">and</span> <span class="nv">try</span> <span class="nv">again</span>.
  <span class="k">if</span> <span class="ss">(</span><span class="o">!</span><span class="nv">GrowHeap</span><span class="ss">(</span><span class="nv">n</span><span class="ss">))</span> {
    <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">Check</span><span class="ss">())</span><span class="c1">;</span>
    <span class="k">return</span> <span class="nv">NULL</span><span class="c1">;</span>
  }
  <span class="k">return</span> <span class="nv">SearchFreeAndLargeLists</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>


<p>```</p>
<p>```
    Span* PageHeap::SearchFreeAndLargeLists(Length n) {
      ASSERT(Check());
      ASSERT(n &gt; 0);</p>
<div class="codehilite"><pre><span></span>  <span class="o">//</span> <span class="nv">Find</span> <span class="nv">first</span> <span class="nv">size</span> <span class="o">&gt;=</span> <span class="nv">n</span> <span class="nv">that</span> <span class="nv">has</span> <span class="nv">a</span> <span class="nv">non</span><span class="o">-</span><span class="nv">empty</span> <span class="nv">list</span>
  <span class="o">//</span> 从<span class="nv">n</span>开始查找,寻找第一个非空的链表.
  <span class="k">for</span> <span class="ss">(</span><span class="nv">Length</span> <span class="nv">s</span> <span class="o">=</span> <span class="nv">n</span><span class="c1">; s &lt; kMaxPages; s++) {</span>
    <span class="nv">Span</span><span class="o">*</span> <span class="nv">ll</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">free_</span>[<span class="nv">s</span>].<span class="nv">normal</span><span class="c1">;</span>
    <span class="o">//</span> <span class="k">If</span> <span class="nv">we</span><span class="s1">&#39;</span><span class="s">re lucky, ll is non-empty, meaning it has a suitable span.</span>
    <span class="k">if</span> <span class="ss">(</span><span class="o">!</span><span class="nv">DLL_IsEmpty</span><span class="ss">(</span><span class="nv">ll</span><span class="ss">))</span> {
      <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">ll</span><span class="o">-&gt;</span><span class="k">next</span><span class="o">-&gt;</span><span class="nv">location</span> <span class="o">==</span> <span class="nv">Span</span>::<span class="nv">ON_NORMAL_FREELIST</span><span class="ss">)</span><span class="c1">;</span>
      <span class="o">//</span> 找到, 然后,我们尝试分割.
      <span class="k">return</span> <span class="nv">Carve</span><span class="ss">(</span><span class="nv">ll</span><span class="o">-&gt;</span><span class="k">next</span>, <span class="nv">n</span><span class="ss">)</span><span class="c1">;</span>
    }
    <span class="o">//</span> <span class="nv">Alternatively</span>, <span class="nv">maybe</span> <span class="nv">there</span><span class="s1">&#39;</span><span class="s">s a usable returned span.</span>
    <span class="o">//</span> <span class="nv">returned</span> 是通过<span class="nv">madvice</span>释放的内存.
    <span class="nv">ll</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">free_</span>[<span class="nv">s</span>].<span class="nv">returned</span><span class="c1">;</span>
    <span class="k">if</span> <span class="ss">(</span><span class="o">!</span><span class="nv">DLL_IsEmpty</span><span class="ss">(</span><span class="nv">ll</span><span class="ss">))</span> {
      <span class="o">//</span> <span class="nv">We</span> <span class="nv">did</span> <span class="nv">not</span> <span class="k">call</span> <span class="nl">EnsureLimit</span> <span class="nv">before</span>, <span class="nv">to</span> <span class="nv">avoid</span> <span class="nv">releasing</span> <span class="nv">the</span> <span class="nv">span</span>
      <span class="o">//</span> <span class="nv">that</span> <span class="nv">will</span> <span class="nv">be</span> <span class="nv">taken</span> <span class="nv">immediately</span> <span class="nv">back</span>.
      <span class="o">//</span> <span class="nv">Calling</span> <span class="nv">EnsureLimit</span> <span class="nv">here</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">very</span> <span class="nv">expensive</span>, <span class="nv">as</span> <span class="nv">it</span> <span class="nv">fails</span> <span class="nv">only</span> <span class="k">if</span>
      <span class="o">//</span> <span class="nv">there</span> <span class="nv">is</span> <span class="nv">no</span> <span class="nv">more</span> <span class="nv">normal</span> <span class="nv">spans</span> <span class="ss">(</span><span class="nv">and</span> <span class="nv">it</span> <span class="nv">fails</span> <span class="nv">efficiently</span><span class="ss">)</span>
      <span class="o">//</span> <span class="nv">or</span> <span class="nv">SystemRelease</span> <span class="nv">does</span> <span class="nv">not</span> <span class="nv">work</span> <span class="ss">(</span><span class="nv">there</span> <span class="nv">is</span> <span class="nv">probably</span> <span class="nv">no</span> <span class="nv">returned</span> <span class="nv">spans</span><span class="ss">)</span>.
      <span class="k">if</span> <span class="ss">(</span><span class="nv">EnsureLimit</span><span class="ss">(</span><span class="nv">n</span><span class="ss">))</span> {
        <span class="o">//</span> <span class="nv">ll</span> <span class="nv">may</span> <span class="nv">have</span> <span class="nv">became</span> <span class="nv">empty</span> <span class="nv">due</span> <span class="nv">to</span> <span class="nv">coalescing</span>
        <span class="k">if</span> <span class="ss">(</span><span class="o">!</span><span class="nv">DLL_IsEmpty</span><span class="ss">(</span><span class="nv">ll</span><span class="ss">))</span> {
          <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">ll</span><span class="o">-&gt;</span><span class="k">next</span><span class="o">-&gt;</span><span class="nv">location</span> <span class="o">==</span> <span class="nv">Span</span>::<span class="nv">ON_RETURNED_FREELIST</span><span class="ss">)</span><span class="c1">;</span>
          <span class="k">return</span> <span class="nv">Carve</span><span class="ss">(</span><span class="nv">ll</span><span class="o">-&gt;</span><span class="k">next</span>, <span class="nv">n</span><span class="ss">)</span><span class="c1">;</span>
        }
      }
    }
  }
  <span class="o">//</span> <span class="nv">No</span> <span class="nv">luck</span> <span class="nv">in</span> <span class="nv">free</span> <span class="nv">lists</span>, <span class="nv">our</span> <span class="nv">last</span> <span class="nv">chance</span> <span class="nv">is</span> <span class="nv">in</span> <span class="nv">a</span> <span class="nv">larger</span> <span class="nv">class</span>.
  <span class="o">//</span> 这是个不幸的消息,我们只能搜索最后一个<span class="nv">large_</span> 链表.
  <span class="k">return</span> <span class="nv">AllocLarge</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="c1">;  // May be NULL</span>
}
</pre></div>


<p>```</p>
<p>由于<code>large_</code> 中的对象没有排序,所以,需要遍历所有,不停地匹配. 这个操作费时, 但基本上逻辑进到这里的几率不高.这里会检查PH的容量,并执行可能需要的内存释放.</p>
<p>```
    Span<em> PageHeap::AllocLarge(Length n) {
      // find the best span (closest to n in size).
      // The following loops implements address-ordered best-fit.
      Span </em>best = NULL;</p>
<div class="codehilite"><pre><span></span>  搜索<span class="nv">normal</span> <span class="nv">list</span>
  <span class="k">for</span> <span class="ss">(</span><span class="nv">Span</span><span class="o">*</span> <span class="nv">span</span> <span class="o">=</span> <span class="nv">large_</span>.<span class="nv">normal</span>.<span class="k">next</span><span class="c1">;</span>
       <span class="nv">span</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nv">large_</span>.<span class="nv">normal</span><span class="c1">;</span>
       <span class="nv">span</span> <span class="o">=</span> <span class="nv">span</span><span class="o">-&gt;</span><span class="k">next</span><span class="ss">)</span> {
    <span class="k">if</span> <span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">&gt;=</span> <span class="nv">n</span><span class="ss">)</span> {
      <span class="k">if</span> <span class="ss">((</span><span class="nv">best</span> <span class="o">==</span> <span class="nv">NULL</span><span class="ss">)</span>
          <span class="o">||</span> <span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">&lt;</span> <span class="nv">best</span><span class="o">-&gt;</span><span class="nv">length</span><span class="ss">)</span>
          <span class="o">||</span> <span class="ss">((</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">==</span> <span class="nv">best</span><span class="o">-&gt;</span><span class="nv">length</span><span class="ss">)</span> <span class="o">&amp;&amp;</span> <span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">&lt;</span> <span class="nv">best</span><span class="o">-&gt;</span><span class="nv">start</span><span class="ss">)))</span> {
        <span class="nv">best</span> <span class="o">=</span> <span class="nv">span</span><span class="c1">;</span>
        <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">best</span><span class="o">-&gt;</span><span class="nv">location</span> <span class="o">==</span> <span class="nv">Span</span>::<span class="nv">ON_NORMAL_FREELIST</span><span class="ss">)</span><span class="c1">;</span>
      }
    }
  }

  <span class="nv">Span</span> <span class="o">*</span><span class="nv">bestNormal</span> <span class="o">=</span> <span class="nv">best</span><span class="c1">;</span>

  <span class="o">//</span> 搜索<span class="nv">returned</span> <span class="nv">list</span>.
  <span class="k">for</span> <span class="ss">(</span><span class="nv">Span</span><span class="o">*</span> <span class="nv">span</span> <span class="o">=</span> <span class="nv">large_</span>.<span class="nv">returned</span>.<span class="k">next</span><span class="c1">;</span>
       <span class="nv">span</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="nv">large_</span>.<span class="nv">returned</span><span class="c1">;</span>
       <span class="nv">span</span> <span class="o">=</span> <span class="nv">span</span><span class="o">-&gt;</span><span class="k">next</span><span class="ss">)</span> {
    <span class="k">if</span> <span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">&gt;=</span> <span class="nv">n</span><span class="ss">)</span> {
      <span class="k">if</span> <span class="ss">((</span><span class="nv">best</span> <span class="o">==</span> <span class="nv">NULL</span><span class="ss">)</span>
          <span class="o">||</span> <span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">&lt;</span> <span class="nv">best</span><span class="o">-&gt;</span><span class="nv">length</span><span class="ss">)</span>
          <span class="o">||</span> <span class="ss">((</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">==</span> <span class="nv">best</span><span class="o">-&gt;</span><span class="nv">length</span><span class="ss">)</span> <span class="o">&amp;&amp;</span> <span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">&lt;</span> <span class="nv">best</span><span class="o">-&gt;</span><span class="nv">start</span><span class="ss">)))</span> {
        <span class="nv">best</span> <span class="o">=</span> <span class="nv">span</span><span class="c1">;</span>
        <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">best</span><span class="o">-&gt;</span><span class="nv">location</span> <span class="o">==</span> <span class="nv">Span</span>::<span class="nv">ON_RETURNED_FREELIST</span><span class="ss">)</span><span class="c1">;</span>
      }
    }
  }

  <span class="o">//</span> <span class="nv">best</span>来自<span class="nv">normal</span>
  <span class="k">if</span> <span class="ss">(</span><span class="nv">best</span> <span class="o">==</span> <span class="nv">bestNormal</span><span class="ss">)</span> {
    <span class="k">return</span> <span class="nv">best</span> <span class="o">==</span> <span class="nv">NULL</span> ? <span class="nv">NULL</span> : <span class="nv">Carve</span><span class="ss">(</span><span class="nv">best</span>, <span class="nv">n</span><span class="ss">)</span><span class="c1">;</span>
  }

  <span class="o">//</span> <span class="nv">best</span> 来自<span class="nv">returned</span>, 我们如果取回<span class="nv">best</span>,需要判断<span class="nv">PH</span>是否达到容量上限.
  <span class="o">//</span> 只是检查.
  <span class="o">//</span> <span class="nv">true</span> 为未达到上限.参数<span class="nv">false</span>表示,达到上限,不释放内存.
  <span class="k">if</span> <span class="ss">(</span><span class="nv">EnsureLimit</span><span class="ss">(</span><span class="nv">n</span>, <span class="nv">false</span><span class="ss">))</span> {
    <span class="k">return</span> <span class="nv">Carve</span><span class="ss">(</span><span class="nv">best</span>, <span class="nv">n</span><span class="ss">)</span><span class="c1">;</span>
  }

  <span class="o">//</span> 容量上限,释放内存.
  <span class="o">//</span> 释放内存的逻辑与<span class="nv">TC</span>的类似,从每个<span class="nv">list</span>中释放一部分.
  <span class="o">//</span> 最后调用<span class="nv">TCMalloc_SystemRelease</span> 进行<span class="nv">madvise</span>释放.
  <span class="o">//</span> 系统必须支持<span class="nv">madvise</span>, 否则<span class="nv">tcmalloc</span>无法工作.
  <span class="k">if</span> <span class="ss">(</span><span class="nv">EnsureLimit</span><span class="ss">(</span><span class="nv">n</span>, <span class="nv">true</span><span class="ss">))</span> {
    <span class="o">//</span> <span class="nv">best</span> <span class="nv">could</span> <span class="nv">have</span> <span class="nv">been</span> <span class="nv">destroyed</span> <span class="nv">by</span> <span class="nv">coalescing</span>.
    <span class="o">//</span> <span class="nv">bestNormal</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">a</span> <span class="nv">best</span><span class="o">-</span><span class="nv">fit</span>, <span class="nv">and</span> <span class="nv">it</span> <span class="nv">could</span> <span class="nv">be</span> <span class="nv">destroyed</span> <span class="nv">as</span> <span class="nv">well</span>.
    <span class="o">//</span> <span class="nv">We</span> <span class="nv">retry</span>, <span class="nv">the</span> <span class="nv">limit</span> <span class="nv">is</span> <span class="nv">already</span> <span class="nv">ensured</span>:
    <span class="k">return</span> <span class="nv">AllocLarge</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="c1">;</span>
  }

  <span class="o">//</span> <span class="k">If</span> <span class="nv">bestNormal</span> <span class="nv">existed</span>, <span class="nv">EnsureLimit</span> <span class="nv">would</span> <span class="nv">succeeded</span>:
  <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">bestNormal</span> <span class="o">==</span> <span class="nv">NULL</span><span class="ss">)</span><span class="c1">;</span>
  <span class="o">//</span> <span class="nv">We</span> <span class="nv">are</span> <span class="nv">not</span> <span class="nv">allowed</span> <span class="nv">to</span> <span class="nv">take</span> <span class="nv">best</span> <span class="nv">from</span> <span class="nv">returned</span> <span class="nv">list</span>.
  <span class="k">return</span> <span class="nv">NULL</span><span class="c1">;</span>
}
</pre></div>


<p>```</p>
<p>我们来看下分割的行为.跟dlmalloc分割内存一样的. 都是将剩下的重新插入到对应的分区中.</p>
<p>```
    Span<em> PageHeap::Carve(Span</em> span, Length n) {
      ASSERT(n &gt; 0);
      ASSERT(span-&gt;location != Span::IN_USE);
      const int old_location = span-&gt;location;
      // 从链表中移除.
      RemoveFromFreeList(span);
      span-&gt;location = Span::IN_USE;
      Event(span, 'A', n);</p>
<div class="codehilite"><pre><span></span>  <span class="nv">const</span> <span class="nv">int</span> <span class="nv">extra</span> <span class="o">=</span> <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">-</span> <span class="nv">n</span><span class="c1">;</span>
  <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">extra</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="ss">)</span><span class="c1">;</span>
  <span class="k">if</span> <span class="ss">(</span><span class="nv">extra</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span> {
    <span class="o">//</span> 将剩余部分生成新的<span class="nv">span</span>
    <span class="nv">Span</span><span class="o">*</span> <span class="nv">leftover</span> <span class="o">=</span> <span class="nv">NewSpan</span><span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">+</span> <span class="nv">n</span>, <span class="nv">extra</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">leftover</span><span class="o">-&gt;</span><span class="nv">location</span> <span class="o">=</span> <span class="nv">old_location</span><span class="c1">;</span>
    <span class="nv">Event</span><span class="ss">(</span><span class="nv">leftover</span>, <span class="s1">&#39;</span><span class="s">S</span><span class="s1">&#39;</span>, <span class="nv">extra</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">RecordSpan</span><span class="ss">(</span><span class="nv">leftover</span><span class="ss">)</span><span class="c1">;</span>
    <span class="o">//</span> 插入对应的<span class="nv">list</span>
    <span class="nv">PrependToFreeList</span><span class="ss">(</span><span class="nv">leftover</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">=</span> <span class="nv">n</span><span class="c1">;</span>
    <span class="o">//</span> 将<span class="nv">span</span>的地址区域和<span class="nv">span</span>的守地址在<span class="nv">radix</span> <span class="nv">tree</span>中对应起来.
    <span class="nv">pagemap_</span>.<span class="nv">set</span><span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">+</span> <span class="nv">n</span> <span class="o">-</span> <span class="mi">1</span>, <span class="nv">span</span><span class="ss">)</span><span class="c1">;</span>
  }
  <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">Check</span><span class="ss">())</span><span class="c1">;</span>
  <span class="k">return</span> <span class="nv">span</span><span class="c1">;</span>
}
</pre></div>


<p>```</p>
<p>然后我们看下GrowHeap, 是如何从系统获取内存的</p>
<p>```
    bool PageHeap::GrowHeap(Length n) {
      ASSERT(kMaxPages &gt;= kMinSystemAlloc);
      if (n &gt; kMaxValidPages) return false;
      // 判断需要请求的page数量.
      Length ask = (n&gt;kMinSystemAlloc) ? n : static_cast<Length>(kMinSystemAlloc);
      size_t actual_size;
      void* ptr = NULL;</p>
<div class="codehilite"><pre><span></span>  <span class="o">//</span> 确定添加<span class="nv">ask</span>的数量后,没有达到容量要求
  <span class="k">if</span> <span class="ss">(</span><span class="nv">EnsureLimit</span><span class="ss">(</span><span class="nv">ask</span><span class="ss">))</span> {
      <span class="nv">ptr</span> <span class="o">=</span> <span class="nv">TCMalloc_SystemAlloc</span><span class="ss">(</span><span class="nv">ask</span> <span class="o">&lt;&lt;</span> <span class="nv">kPageShift</span>, <span class="o">&amp;</span><span class="nv">actual_size</span>, <span class="nv">kPageSize</span><span class="ss">)</span><span class="c1">;</span>
  }
  <span class="k">if</span> <span class="ss">(</span><span class="nv">ptr</span> <span class="o">==</span> <span class="nv">NULL</span><span class="ss">)</span> {
    <span class="k">if</span> <span class="ss">(</span><span class="nv">n</span> <span class="o">&lt;</span> <span class="nv">ask</span><span class="ss">)</span> {
      <span class="o">//</span> <span class="nv">Try</span> <span class="nv">growing</span> <span class="nv">just</span> <span class="s2">&quot;</span><span class="s">n</span><span class="s2">&quot;</span> <span class="nv">pages</span>
      <span class="nv">ask</span> <span class="o">=</span> <span class="nv">n</span><span class="c1">;</span>
      <span class="k">if</span> <span class="ss">(</span><span class="nv">EnsureLimit</span><span class="ss">(</span><span class="nv">ask</span><span class="ss">))</span> {
        <span class="nv">ptr</span> <span class="o">=</span> <span class="nv">TCMalloc_SystemAlloc</span><span class="ss">(</span><span class="nv">ask</span> <span class="o">&lt;&lt;</span> <span class="nv">kPageShift</span>, <span class="o">&amp;</span><span class="nv">actual_size</span>, <span class="nv">kPageSize</span><span class="ss">)</span><span class="c1">;</span>
      }
    }
    <span class="k">if</span> <span class="ss">(</span><span class="nv">ptr</span> <span class="o">==</span> <span class="nv">NULL</span><span class="ss">)</span> <span class="k">return</span> <span class="nv">false</span><span class="c1">;</span>
  }
  <span class="nv">ask</span> <span class="o">=</span> <span class="nv">actual_size</span> <span class="o">&gt;&gt;</span> <span class="nv">kPageShift</span><span class="c1">;</span>
  <span class="nv">RecordGrowth</span><span class="ss">(</span><span class="nv">ask</span> <span class="o">&lt;&lt;</span> <span class="nv">kPageShift</span><span class="ss">)</span><span class="c1">;</span>

  <span class="o">//</span> 记录系统已经分配的<span class="nv">page</span>数量.
  <span class="nv">uint64_t</span> <span class="nv">old_system_bytes</span> <span class="o">=</span> <span class="nv">stats_</span>.<span class="nv">system_bytes</span><span class="c1">;</span>
  <span class="nv">stats_</span>.<span class="nv">system_bytes</span> <span class="o">+=</span> <span class="ss">(</span><span class="nv">ask</span> <span class="o">&lt;&lt;</span> <span class="nv">kPageShift</span><span class="ss">)</span><span class="c1">;</span>
  <span class="nv">const</span> <span class="nv">PageID</span> <span class="nv">p</span> <span class="o">=</span> <span class="nv">reinterpret_cast</span><span class="o">&lt;</span><span class="nv">uintptr_t</span><span class="o">&gt;</span><span class="ss">(</span><span class="nv">ptr</span><span class="ss">)</span> <span class="o">&gt;&gt;</span> <span class="nv">kPageShift</span><span class="c1">;</span>
  <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span><span class="c1">;</span>

  <span class="o">//</span> <span class="k">If</span> <span class="nv">we</span> <span class="nv">have</span> <span class="nv">already</span> <span class="nv">a</span> <span class="nv">lot</span> <span class="nv">of</span> <span class="nv">pages</span> <span class="nv">allocated</span>, <span class="nv">just</span> <span class="nv">pre</span> <span class="nv">allocate</span> <span class="nv">a</span> <span class="nv">bunch</span> <span class="nv">of</span>
  <span class="o">//</span> <span class="nv">memory</span> <span class="k">for</span> <span class="nv">the</span> <span class="nv">page</span> <span class="nv">map</span>. <span class="nv">This</span> <span class="nv">prevents</span> <span class="nv">fragmentation</span> <span class="nv">by</span> <span class="nv">pagemap</span> <span class="nv">metadata</span>
  <span class="o">//</span> <span class="nv">when</span> <span class="nv">a</span> <span class="nv">program</span> <span class="nv">keeps</span> <span class="nv">allocating</span> <span class="nv">and</span> <span class="nv">freeing</span> <span class="nv">large</span> <span class="nv">blocks</span>.
  <span class="k">if</span> <span class="ss">(</span><span class="nv">old_system_bytes</span> <span class="o">&lt;</span> <span class="nv">kPageMapBigAllocationThreshold</span>
      <span class="o">&amp;&amp;</span> <span class="nv">stats_</span>.<span class="nv">system_bytes</span> <span class="o">&gt;=</span> <span class="nv">kPageMapBigAllocationThreshold</span><span class="ss">)</span> {
    <span class="nv">pagemap_</span>.<span class="nv">PreallocateMoreMemory</span><span class="ss">()</span><span class="c1">;</span>
  }

  <span class="o">//</span> <span class="nv">Make</span> <span class="nv">sure</span> <span class="nv">pagemap_</span> <span class="nv">has</span> <span class="nv">entries</span> <span class="k">for</span> <span class="nv">all</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">new</span> <span class="nv">pages</span>.
  <span class="o">//</span> <span class="nv">Plus</span> <span class="nv">ensure</span> <span class="nv">one</span> <span class="nv">before</span> <span class="nv">and</span> <span class="nv">one</span> <span class="nv">after</span> <span class="nv">so</span> <span class="nv">coalescing</span> <span class="nv">code</span>
  <span class="o">//</span> <span class="nv">does</span> <span class="nv">not</span> <span class="nv">need</span> <span class="nv">bounds</span><span class="o">-</span><span class="nv">checking</span>.
  <span class="o">//</span> 与前一个合并,如果前一个是空闲的话.
  <span class="k">if</span> <span class="ss">(</span><span class="nv">pagemap_</span>.<span class="nv">Ensure</span><span class="ss">(</span><span class="nv">p</span><span class="o">-</span><span class="mi">1</span>, <span class="nv">ask</span><span class="o">+</span><span class="mi">2</span><span class="ss">))</span> {
    <span class="o">//</span> <span class="nv">Pretend</span> <span class="nv">the</span> <span class="nv">new</span> <span class="nv">area</span> <span class="nv">is</span> <span class="nv">allocated</span> <span class="nv">and</span> <span class="k">then</span> <span class="nv">Delete</span><span class="ss">()</span> <span class="nv">it</span> <span class="nv">to</span> <span class="nv">cause</span>
    <span class="o">//</span> <span class="nv">any</span> <span class="nv">necessary</span> <span class="nv">coalescing</span> <span class="nv">to</span> <span class="nv">occur</span>.
    <span class="nv">Span</span><span class="o">*</span> <span class="nv">span</span> <span class="o">=</span> <span class="nv">NewSpan</span><span class="ss">(</span><span class="nv">p</span>, <span class="nv">ask</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">RecordSpan</span><span class="ss">(</span><span class="nv">span</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">Delete</span><span class="ss">(</span><span class="nv">span</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">Check</span><span class="ss">())</span><span class="c1">;</span>
    <span class="k">return</span> <span class="nv">true</span><span class="c1">;</span>
  } <span class="k">else</span> {
    <span class="o">//</span> <span class="nv">We</span> <span class="nv">could</span> <span class="nv">not</span> <span class="nv">allocate</span> <span class="nv">memory</span> <span class="nv">within</span> <span class="s2">&quot;</span><span class="s">pagemap_</span><span class="s2">&quot;</span>
    <span class="o">//</span> <span class="nv">TODO</span>: <span class="nv">Once</span> <span class="nv">we</span> <span class="nv">can</span> <span class="k">return</span> <span class="nv">memory</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">system</span>, <span class="k">return</span> <span class="nv">the</span> <span class="nv">new</span> <span class="nv">span</span>
    <span class="k">return</span> <span class="nv">false</span><span class="c1">;</span>
  }
}
</pre></div>


<p>```</p>
<p>然后,就是跟系统互动的 <code>TCMalloc::SystemAlloc</code>.其中有两个allocator, mmap和
sbrk.它会遍历所有的allocs, 直到能成功分配内存.在我们的系统上,先尝试sbrk,然后才是mmap.</p>
<p><code>void* DefaultSysAllocator::Alloc(size_t size, size_t *actual_size,
                                     size_t alignment) {
      for (int i = 0; i &lt; kMaxAllocators; i++) {
        if (!failed_[i] &amp;&amp; allocs_[i] != NULL) {
          void* result = allocs_[i]-&gt;Alloc(size, actual_size, alignment);
          if (result != NULL) {
            return result;
          }
          failed_[i] = true;
        }
      }
      // After both failed, reset "failed_" to false so that a single failed
      // allocation won't make the allocator never work again.
      for (int i = 0; i &lt; kMaxAllocators; i++) {
        failed_[i] = false;
      }
      return NULL;
    }</code></p>
</li>
<li>
<p>CC 向PH 释放内存</p>
<p>CC向PH释放内存的条件是, slots满,并且span中objects全部回收 (refcount为0). 前文提到,CC和PH之间移动的单位时span, 所以, 释放时需要的参数就是 span. PageHeap::Delete(Span * span). 该函数的作用就是将释放的内存与其前后空闲内存合并,插入size class.</p>
<div class="codehilite"><pre><span></span><span class="o">*</span> <span class="err">首先</span><span class="p">,</span><span class="err">从</span><span class="n">PageMap获取到相连的span</span><span class="p">,</span> <span class="err">如果它们都是空闲的</span><span class="p">,</span><span class="err">则进行合并</span><span class="p">.</span>
<span class="o">*</span> <span class="err">将合并后的新</span><span class="n">span或者不需要合并的span插入对应的free</span> <span class="n">list中</span><span class="p">.</span>
<span class="o">*</span> <span class="n">PageHeap检查是否需要释放内存到系统</span><span class="p">.</span><span class="err">这里释放的机制与</span><span class="n">TC释放的机制有点不同</span><span class="p">,</span><span class="err">不会针对某个分类大小进行释放</span><span class="p">,</span><span class="err">而是针对整个</span><span class="n">PH进行释放</span><span class="p">.</span>
</pre></div>


<p><code>void PageHeap::Delete(Span* span) {
      ASSERT(Check());
      ASSERT(span-&gt;location == Span::IN_USE);
      ASSERT(span-&gt;length &gt; 0);
      ASSERT(GetDescriptor(span-&gt;start) == span);
      ASSERT(GetDescriptor(span-&gt;start + span-&gt;length - 1) == span);
      const Length n = span-&gt;length;
      span-&gt;sizeclass = 0;
      span-&gt;sample = 0;
      // 设置为在normal list
      span-&gt;location = Span::ON_NORMAL_FREELIST;
      Event(span, 'D', span-&gt;length);
      // 与前后合并
      MergeIntoFreeList(span);  // Coalesces if possible
      // 内存释放的逻辑.
      IncrementalScavenge(n);
      ASSERT(Check());
    }</code></p>
<p>首先我们看下合并的逻辑. 跟dlmalloc其实没差. 即使根据span的获取到对应的 pageID,然后查找(pageID - 1) 的page和(pageID +１)的page,如果都为空闲,合并.</p>
<p>```
    void PageHeap::MergeIntoFreeList(Span* span) {
      ASSERT(span-&gt;location != Span::IN_USE);</p>
<div class="codehilite"><pre><span></span>  <span class="nv">const</span> <span class="nv">PageID</span> <span class="nv">p</span> <span class="o">=</span> <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span><span class="c1">;</span>
  <span class="nv">const</span> <span class="nv">Length</span> <span class="nv">n</span> <span class="o">=</span> <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span><span class="c1">;</span>
  <span class="o">//</span> <span class="nv">GetDescriptor</span> 就是通过<span class="nv">pagemap</span>, 将<span class="nv">pageID</span>映射成<span class="nv">span</span>的地址.
  <span class="nv">Span</span><span class="o">*</span> <span class="nv">prev</span> <span class="o">=</span> <span class="nv">GetDescriptor</span><span class="ss">(</span><span class="nv">p</span><span class="o">-</span><span class="mi">1</span><span class="ss">)</span><span class="c1">;</span>
  <span class="o">//</span> 这里的<span class="nv">location</span>, 不是跟地址相关的,而是表示这个<span class="nv">span</span>存在的<span class="nv">list</span><span class="ss">(</span><span class="nv">normal</span> <span class="nv">or</span> <span class="nv">returned</span><span class="ss">)</span>
  <span class="o">//</span> 这里是保证, <span class="nv">normal</span>中的<span class="nv">span</span>不会和<span class="nv">returned</span>中的<span class="nv">span</span>进行合并.
  <span class="k">if</span> <span class="ss">(</span><span class="nv">prev</span> <span class="o">!=</span> <span class="nv">NULL</span> <span class="o">&amp;&amp;</span> <span class="nv">prev</span><span class="o">-&gt;</span><span class="nv">location</span> <span class="o">==</span> <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">location</span><span class="ss">)</span> {
    <span class="o">//</span> <span class="nv">Merge</span> <span class="nv">preceding</span> <span class="nv">span</span> <span class="nv">into</span> <span class="nv">this</span> <span class="nv">span</span>
    <span class="nv">ASSERT</span><span class="ss">(</span><span class="nv">prev</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">+</span> <span class="nv">prev</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">==</span> <span class="nv">p</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">const</span> <span class="nv">Length</span> <span class="nv">len</span> <span class="o">=</span> <span class="nv">prev</span><span class="o">-&gt;</span><span class="nv">length</span><span class="c1">;</span>
    <span class="o">//</span> 将上一个<span class="nv">span</span>从队列移除
    <span class="nv">RemoveFromFreeList</span><span class="ss">(</span><span class="nv">prev</span><span class="ss">)</span><span class="c1">;</span>
    <span class="o">//</span> 删除<span class="nv">span</span>对象
    <span class="nv">DeleteSpan</span><span class="ss">(</span><span class="nv">prev</span><span class="ss">)</span><span class="c1">;</span>
    <span class="o">//</span> 合并首地址
    <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">-=</span> <span class="nv">len</span><span class="c1">;</span>
    <span class="o">//</span> 合并长度
    <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">+=</span> <span class="nv">len</span><span class="c1">;</span>
    <span class="o">//</span> 将新<span class="nv">span</span>的<span class="nv">pageID</span>和<span class="nv">span</span>的地址在<span class="nv">pagemap</span>中进行映射
    <span class="nv">pagemap_</span>.<span class="nv">set</span><span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span>, <span class="nv">span</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">Event</span><span class="ss">(</span><span class="nv">span</span>, <span class="s1">&#39;</span><span class="s">L</span><span class="s1">&#39;</span>, <span class="nv">len</span><span class="ss">)</span><span class="c1">;</span>
  }
  <span class="o">//</span> <span class="nv">same</span> <span class="nv">as</span> <span class="nv">above</span>
  <span class="nv">Span</span><span class="o">*</span> <span class="k">next</span> <span class="o">=</span> <span class="nv">GetDescriptor</span><span class="ss">(</span><span class="nv">p</span><span class="o">+</span><span class="nv">n</span><span class="ss">)</span><span class="c1">;</span>
  <span class="k">if</span> <span class="ss">(</span><span class="k">next</span> <span class="o">!=</span> <span class="nv">NULL</span> <span class="o">&amp;&amp;</span> <span class="k">next</span><span class="o">-&gt;</span><span class="nv">location</span> <span class="o">==</span> <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">location</span><span class="ss">)</span> {
    <span class="o">//</span> <span class="nv">Merge</span> <span class="k">next</span> <span class="nv">span</span> <span class="nv">into</span> <span class="nv">this</span> <span class="nv">span</span>
    <span class="nv">ASSERT</span><span class="ss">(</span><span class="k">next</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">==</span> <span class="nv">p</span><span class="o">+</span><span class="nv">n</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">const</span> <span class="nv">Length</span> <span class="nv">len</span> <span class="o">=</span> <span class="k">next</span><span class="o">-&gt;</span><span class="nv">length</span><span class="c1">;</span>
    <span class="nv">RemoveFromFreeList</span><span class="ss">(</span><span class="k">next</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">DeleteSpan</span><span class="ss">(</span><span class="k">next</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">+=</span> <span class="nv">len</span><span class="c1">;</span>
    <span class="nv">pagemap_</span>.<span class="nv">set</span><span class="ss">(</span><span class="nv">span</span><span class="o">-&gt;</span><span class="nv">start</span> <span class="o">+</span> <span class="nv">span</span><span class="o">-&gt;</span><span class="nv">length</span> <span class="o">-</span> <span class="mi">1</span>, <span class="nv">span</span><span class="ss">)</span><span class="c1">;</span>
    <span class="nv">Event</span><span class="ss">(</span><span class="nv">span</span>, <span class="s1">&#39;</span><span class="s">R</span><span class="s1">&#39;</span>, <span class="nv">len</span><span class="ss">)</span><span class="c1">;</span>
  }

  <span class="o">//</span> 重新将生成的<span class="nv">span</span>插入相应的<span class="nv">list</span>中.
  <span class="nv">PrependToFreeList</span><span class="ss">(</span><span class="nv">span</span><span class="ss">)</span><span class="c1">;</span>
}
</pre></div>


<p>```</p>
<p>下面,我们看下增量释放函数IncrementalScavenge.它不是每次都进行内存释放.当某此内存未释放的情况下,会等待一段时间. 所以,PH的容量是允许超过的.</p>
<p>```
    void PageHeap::IncrementalScavenge(Length n) {
      // Fast path; not yet time to release memory
      // scaveng_counter_ 是一个超时计数,单位为page数.
      scavenge_counter_ -= n;
      if (scavenge_counter_ &gt;= 0) return;  // Not yet time to scavenge</p>
<div class="codehilite"><pre><span></span>  <span class="o">//</span> 回收率, 如果过低,则不回收
  <span class="nv">const</span> <span class="nv">double</span> <span class="nv">rate</span> <span class="o">=</span> <span class="nv">FLAGS_tcmalloc_release_rate</span><span class="c1">;</span>
  <span class="k">if</span> <span class="ss">(</span><span class="nv">rate</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="nv">e</span><span class="o">-</span><span class="mi">6</span><span class="ss">)</span> {
    <span class="o">//</span> <span class="nv">Tiny</span> <span class="nv">release</span> <span class="nv">rate</span> <span class="nv">means</span> <span class="nv">that</span> <span class="nv">releasing</span> <span class="nv">is</span> <span class="nv">disabled</span>.
    <span class="nv">scavenge_counter_</span> <span class="o">=</span> <span class="nv">kDefaultReleaseDelay</span><span class="c1">;</span>
    <span class="k">return</span><span class="c1">;</span>
  }

  <span class="o">//</span> 尝试释放一个页面, 实际上是以<span class="nv">span</span>为单位释放. 也就是说,
  <span class="o">//</span> 页面数会对齐到一个<span class="nv">span</span>中,然后释放该<span class="nv">span</span>.
  <span class="nv">Length</span> <span class="nv">released_pages</span> <span class="o">=</span> <span class="nv">ReleaseAtLeastNPages</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span><span class="c1">;</span>

  <span class="o">//</span> 实际没归还,则等待默认长度.
  <span class="o">//</span> 没归还的原因是, 系统不支持<span class="nv">madvise</span>或者内存释放失败.
  <span class="k">if</span> <span class="ss">(</span><span class="nv">released_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="ss">)</span> {
    <span class="o">//</span> <span class="nv">Nothing</span> <span class="nv">to</span> <span class="nv">scavenge</span>, <span class="nv">delay</span> <span class="k">for</span> <span class="nv">a</span> <span class="k">while</span>.
    <span class="o">//</span> <span class="nv">kDefaultReleaseDelay</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span><span class="c1">; 基本等于是不再释放内存.</span>
    <span class="nv">scavenge_counter_</span> <span class="o">=</span> <span class="nv">kDefaultReleaseDelay</span><span class="c1">;</span>
  } <span class="k">else</span> {
    <span class="o">//</span> <span class="nv">Compute</span> <span class="nv">how</span> <span class="nv">long</span> <span class="nv">to</span> <span class="k">wait</span> <span class="k">until</span> <span class="nv">we</span> <span class="k">return</span> <span class="nv">memory</span>.
    <span class="o">//</span> <span class="nv">FLAGS_tcmalloc_release_rate</span><span class="o">==</span><span class="mi">1</span> <span class="nv">means</span> <span class="k">wait</span> <span class="k">for</span> <span class="mi">1000</span> <span class="nv">pages</span>
    <span class="o">//</span> <span class="nv">after</span> <span class="nv">releasing</span> <span class="nv">one</span> <span class="nv">page</span>.
    <span class="o">//</span> 释放成功,则计算下一次等待时间.
    <span class="nv">const</span> <span class="nv">double</span> <span class="nv">mult</span> <span class="o">=</span> <span class="mi">1000</span>.<span class="mi">0</span> <span class="o">/</span> <span class="nv">rate</span><span class="c1">;</span>
    <span class="nv">double</span> <span class="k">wait</span> <span class="o">=</span> <span class="nv">mult</span> <span class="o">*</span> <span class="nv">static_cast</span><span class="o">&lt;</span><span class="nv">double</span><span class="o">&gt;</span><span class="ss">(</span><span class="nv">released_pages</span><span class="ss">)</span><span class="c1">;</span>
    <span class="k">if</span> <span class="ss">(</span><span class="k">wait</span> <span class="o">&gt;</span> <span class="nv">kMaxReleaseDelay</span><span class="ss">)</span> {
      <span class="o">//</span> <span class="nv">Avoid</span> <span class="nv">overflow</span> <span class="nv">and</span> <span class="nv">bound</span> <span class="nv">to</span> <span class="nv">reasonable</span> <span class="nv">range</span>.
      <span class="k">wait</span> <span class="o">=</span> <span class="nv">kMaxReleaseDelay</span><span class="c1">;</span>
    }
    <span class="nv">scavenge_counter_</span> <span class="o">=</span> <span class="nv">static_cast</span><span class="o">&lt;</span><span class="nv">int64_t</span><span class="o">&gt;</span><span class="ss">(</span><span class="k">wait</span><span class="ss">)</span><span class="c1">;</span>
  }
}
</pre></div>


<p>```</p>
<p>我们看下ReleaseAtLeastNPages, 这东西释放的单位为span, 所以,传入的参数, page数量,实际上是指最小需要释放长度,达到了或者没有可释放的span,则停止, 否则,持续释放.</p>
<p>```
    Length PageHeap::ReleaseAtLeastNPages(Length num_pages) {
      Length released_pages = 0;</p>
<div class="codehilite"><pre><span></span>  <span class="o">//</span> <span class="nv">Round</span> <span class="nv">robin</span> <span class="nv">through</span> <span class="nv">the</span> <span class="nv">lists</span> <span class="nv">of</span> <span class="nv">free</span> <span class="nv">spans</span>, <span class="nv">releasing</span> <span class="nv">the</span> <span class="nv">last</span>
  <span class="o">//</span> <span class="nv">span</span> <span class="nv">in</span> <span class="nv">each</span> <span class="nv">list</span>.  <span class="nv">Stop</span> <span class="nv">after</span> <span class="nv">releasing</span> <span class="nv">at</span> <span class="nv">least</span> <span class="nv">num_pages</span>
  <span class="o">//</span> <span class="nv">or</span> <span class="nv">when</span> <span class="nv">there</span> <span class="nv">is</span> <span class="nv">nothing</span> <span class="nv">more</span> <span class="nv">to</span> <span class="nv">release</span>.
  <span class="k">while</span> <span class="ss">(</span><span class="nv">released_pages</span> <span class="o">&lt;</span> <span class="nv">num_pages</span> <span class="o">&amp;&amp;</span> <span class="nv">stats_</span>.<span class="nv">free_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span> {
    <span class="k">for</span> <span class="ss">(</span><span class="nv">int</span> <span class="nv">i</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">; i &lt; kMaxPages+1 &amp;&amp; released_pages &lt; num_pages;</span>
         <span class="nv">i</span><span class="o">++</span>, <span class="nv">release_index_</span><span class="o">++</span><span class="ss">)</span> {
      <span class="k">if</span> <span class="ss">(</span><span class="nv">release_index_</span> <span class="o">&gt;</span> <span class="nv">kMaxPages</span><span class="ss">)</span> <span class="nv">release_index_</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">;</span>
      <span class="nv">SpanList</span><span class="o">*</span> <span class="nv">slist</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">release_index_</span> <span class="o">==</span> <span class="nv">kMaxPages</span><span class="ss">)</span> ?
          <span class="o">&amp;</span><span class="nv">large_</span> : <span class="o">&amp;</span><span class="nv">free_</span>[<span class="nv">release_index_</span>]<span class="c1">;</span>
      <span class="k">if</span> <span class="ss">(</span><span class="o">!</span><span class="nv">DLL_IsEmpty</span><span class="ss">(</span><span class="o">&amp;</span><span class="nv">slist</span><span class="o">-&gt;</span><span class="nv">normal</span><span class="ss">))</span> {
        <span class="o">//</span> 获取<span class="nv">normal</span>非空的<span class="nv">list</span>, 释放其最后一个<span class="nv">span</span>.
        <span class="nv">Length</span> <span class="nv">released_len</span> <span class="o">=</span> <span class="nv">ReleaseLastNormalSpan</span><span class="ss">(</span><span class="nv">slist</span><span class="ss">)</span><span class="c1">;</span>
        <span class="o">//</span> <span class="nv">Some</span> <span class="nv">systems</span> <span class="k">do</span> <span class="nv">not</span> <span class="nv">support</span> <span class="nv">release</span>
        <span class="k">if</span> <span class="ss">(</span><span class="nv">released_len</span> <span class="o">==</span> <span class="mi">0</span><span class="ss">)</span> <span class="k">return</span> <span class="nv">released_pages</span><span class="c1">;</span>
        <span class="nv">released_pages</span> <span class="o">+=</span> <span class="nv">released_len</span><span class="c1">;</span>
      }
    }
  }
  <span class="k">return</span> <span class="nv">released_pages</span><span class="c1">;</span>
}
</pre></div>


<p>```</p>
<p>在ReleaseLastNormalSpan中,就是取出list中最后一个span, 调用 TCMalloc::SystemRelease,释放.而 TCMalloc::SystemRelease中,实际调用的是madvise实现.</p>
</li>
</ul>
</li>
</ul>
<h3 id="_4">大对象内存分配<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>在分析小内存时,在请求内存数 &gt; kMaxSize(256k)时, 则执行大内存分配. 大内存的分配某些规则与CC向PH申请内存一样.</p>
<ul>
<li>根据请求大小,对齐到PH的分类中最接近的大小, 获取到 <code>num_pages</code>.</li>
<li>执行 <code>PageHeap::New(Length n)</code>, 与CC向PH申请内存一样.</li>
</ul>
<p>而内存释放, 我们在小内存时,已经提到. 并且,其行为跟CC向PH释放内存逻辑一样.</p>
<ul>
<li>根据被释放的内存, 获取其pageID.</li>
<li>如果pageID属于span, 则调用 <code>PageHeap::Delete(Span* span)</code> .</li>
</ul>
<h3 id="_5">算法<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<h2 id="review">代码review<a class="headerlink" href="#review" title="Permanent link">&para;</a></h2>
<h2 id="_6">总结<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<h3 id="tcmalloc">tcmalloc优势<a class="headerlink" href="#tcmalloc" title="Permanent link">&para;</a></h3>
<ul>
<li>我们可以将tcmalloc中的模块与dlmalloc中作映射. CC 看成dlmalloc中小内存模块, PH看成dlmalloc中的大内存模块.则tcmalloc中多了一个无锁的TC模块.所以,在小内存上存在的一个优势是,可以在一定范围内无锁获取和释放内存.</li>
<li>第一条优势的前提是,TC空间足够. 但就算空间不够的情况下, TC向CC请求内存, 最多也是每2次TC请求需要加解一次锁.而CC向PH请求内存,在小内存的情况下,永远不可能出现每一次CC请求触发一次PH请求.</li>
</ul>
<h3 id="tcmalloc_1">tcmalloc劣势<a class="headerlink" href="#tcmalloc_1" title="Permanent link">&para;</a></h3>
<ul>
<li>tcmalloc的劣势,很明显,由于存在3级内存请求,和大量内存的预分配, 其初始化的速度比dlmalloc慢很多.</li>
<li>由于对于每个线程存在TC, 空间浪费相对dlmalloc会多一些.虽然存在各种算法和优化了tcmalloc中数据块的结构,但在线程数多和内存请求次数大的情况下,依然不可避免地在TC中浪费了内存.</li>
<li>内存碎片率高. 属于个人理解.在tcmalloc中,只对相连的pages(spans)进行合并,而pages的单位为4K, 相当于,这个page中只要存在被使用的内存,就永远不会与前后的page进行合并. 而在dlmalloc中,存在边界标记法,任何一个释放的内存块(任意大小),只要其相连块有空闲,则进行合并.</li>
</ul>
<h2 id="mem">对mem测试的数据总结<a class="headerlink" href="#mem" title="Permanent link">&para;</a></h2>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/tcmalloc2.1浅析-2.png" /></p>
<p><img alt="" src="https://pengzhang.netlify.com/assets/images/tcmalloc2.1浅析-3.png" /></p>
<ul>
<li>
<p>对图表的几个说明:</p>
<ul>
<li>图表是在线程数为4的基础上做的测试. 并且是在连续分配一定次数的内存后再连续释放,数据只能从一定程度上反映了tcmalloc与dlmalloc的性能差异.</li>
<li>本次测试是计算出4个线程的内存请求和释放的平均时间, 和标准偏差.由于图表维度不够,只使用了平均时间作为实际的性能比较.</li>
<li>测试时的两个变量分别为, 单次申请内存大小,和申请次数,性能指标为执行所有内存申请释放的线程平均时间.</li>
<li>该数据不包含内存分配器初始化的时间(即,第一次内存分配时间).实际上,内存分配器初始化,tcmalloc花费的时间是dlmalloc多.但只是针对第一次,所以,不记录到图标数据中.</li>
<li>以下所有提到的内存申请数,如未说明,都是指单次内存申请的大小.</li>
</ul>
</li>
<li>
<p>分析:</p>
<ul>
<li>tcmalloc 内存分配概要:<ul>
<li>tcmalloc 中存在分级请求内存的机制. 分为3级,分别为TC(ThreadCache), CC(Central Cache) 和 PH(PageHeap)</li>
<li>TC 向CC 申请内存, CC 向PH申请内存. 而他们之间的内存是批量移动,一般为申请内存对齐后的N倍进行移动.</li>
<li>TC 存在线程局部空间中. 向TC申请内存不需要加解锁,向CC和PH 申请内存需要加解锁.</li>
</ul>
</li>
<li>
<p>dlmalloc 内存分配概要:</p>
<ul>
<li>dlmalloc每次内存申请都会执行加解锁操作.</li>
<li>256byte以下的内存,从小内存分配.256byte以上的从大内存分配.在空闲内存不够并且申请内存大于256K的,直接由mmap分配.</li>
</ul>
</li>
<li>
<p>首先,从图表可以得出一个结论,在单次内存30K以内的内存分配和释放, 效率上,tcmalloc比dlmalloc高,并且在1K以内,申请次数大于26次的情况下,甚至可以达到10倍性能.原因是,在tcmalloc中,所有小于256k的内存都会优先从TC(避免加解锁操作)分配, 在TC不够的情况下,向CC申请 2 - 32 倍的内存数量,并存放到TC中,相当于, N(N&gt;2)次内存请求才执行1次加解锁.而dlmalloc每次内存请求都会加解锁.所以,tcmalloc在小内存分配上,性能高于dlmalloc.</p>
</li>
<li>而在30K - 256K,在某些区域内,tcmalloc的性能反而不如dlmalloc. 可能原因如下: tcmalloc在每次往CC中拷贝数据时, 有个大小上限为64K,也有一个最小下限为2倍请求内存对齐后的大小. 所以,在这个区间内,相当于每2次内存请求都会加解一次锁. 而CC也有存在内存不足的情况,也会出现加解锁,进一步向PH申请空间. 所以,就相当于每次内存申请都会加解锁.至于,在申请次数达到一定值之后,tcmalloc的性能又高于dlmalloc的原因是:CC与PH之间的内存移动的值是动态修正的,也就是说,在申请次数达到一定值之后,CC向PH申请的内存数变大,而请求次数减少,导致tcmalloc的性能再次提升.</li>
<li>
<blockquote>
<p>256K 的情况下,tcmalloc的性能也略好于dlmalloc. 原因未知.分析如下. 在这种情况下,对于dlmalloc而言,如果没有足够空闲内存(本次测试中不可能有足够空闲内存), dlmalloc会直接调用mmap进行内存分配, 相当与一次加解锁,一次系统调用的时间.而tcmalloc依然向PH申请内存,当然PH也会直接从系统分配.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>结论: (以下结论,只有1从图表中得出)</p>
<ul>
<li>大量小内存请求的情况下,tcmalloc性能高于dlmalloc, 节省了加解锁的时间.</li>
<li>如果只存在少量的内存请求,即使是小内存,从总的申请内存时间上,dlmalloc会优于tcmalloc,原因是,在第一次内存申请时,tcmalloc初始化的时间是dlmalloc的近10倍.</li>
<li>从代码中分析,tcmalloc的内存利用率小于dlmalloc,虽然,tcmalloc使用了各种算法来提高内存利用率,但依然无法避免线程局部空间中的内存浪费.</li>
</ul>
</li>
<li>
<p>该测试的局限性:</p>
<ul>
<li>由于该测试是连续内存申请之后,连续释放,所以无法测试申请已释放内存的效率.但从代码上和tcmalloc/dlmalloc加解锁的机制上看, tcmalloc 依然会优于 dlmalloc.</li>
<li>无法测试对于生命周期超长的进程,内存的碎片率.</li>
</ul>
</li>
</ul>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../SEAndroid规则介绍/" title="Android SELinux 规则介绍" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                Android SELinux 规则介绍
              </span>
            </div>
          </a>
        
        
          <a href="../dlmalloc浅析/" title="dlmalloc 浅析" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                dlmalloc 浅析
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2018 Werther Zhang
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../assets/fonts/font-awesome.css">
    
      <a href="http://wertherzhang.coding.me/" class="md-footer-social__link fa fa-coding"></a>
    
      <a href="https://pengzhang.netlify.com/" class="md-footer-social__link fa fa-netlify"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.245445c6.js"></script>
      
        
        
          
          <script src="../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
          
            
              
              
            
          
          
            <script src="../assets/javascripts/lunr/lunr.multi.js"></script>
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>